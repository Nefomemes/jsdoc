{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"JSDoc An API documentation generator for JavaScript. Want to contribute to JSDoc? Please read CONTRIBUTING.md . Installation and Usage JSDoc supports stable versions of Node.js 8.15.0 and later. You can install JSDoc globally or in your project's node_modules folder. To install the latest version on npm globally (might require sudo ; learn how to fix this ): npm install -g jsdoc To install the latest version on npm locally and save it in your package's package.json file: npm install --save-dev jsdoc Note : By default, npm adds your package using the caret operator in front of the version number (for example, ^3.6.3 ). We recommend using the tilde operator instead (for example, ~3.6.3 ), which limits updates to the most recent patch-level version. See this Stack Overflow answer for more information about the caret and tilde operators. If you installed JSDoc locally, the JSDoc command-line tool is available in ./node_modules/.bin . To generate documentation for the file yourJavaScriptFile.js : ./node_modules/.bin/jsdoc yourJavaScriptFile.js If you installed JSDoc globally, run the jsdoc command: jsdoc yourJavaScriptFile.js By default, the generated documentation is saved in a directory named out . You can use the --destination ( -d ) option to specify another directory. Run jsdoc --help for a complete list of command-line options. Templates and tools The JSDoc community has created templates and other tools to help you generate and customize your documentation. Here are a few of them: Templates jaguarjs-jsdoc DocStrap ( example ) jsdoc3Template ( example ) minami docdash ( example ) tui-jsdoc-template ( example ) better-docs ( example ) Build tools JSDoc Grunt plugin JSDoc Gulp plugin JSDoc GitHub Action Other tools jsdoc-to-markdown Integrating GitBook with JSDoc For more information Documentation is available at jsdoc.app . Contribute to the docs at jsdoc/jsdoc.github.io . Join JSDoc's Slack channel . Ask for help on the JSDoc Users mailing list . Post questions tagged jsdoc to Stack Overflow . License JSDoc is copyright (c) 2011-present Michael Mathews micmath@gmail.com and the contributors to JSDoc . JSDoc is free software, licensed under the Apache License, Version 2.0. See the LICENSE file for more details.","title":"Index"},{"location":"#jsdoc","text":"An API documentation generator for JavaScript. Want to contribute to JSDoc? Please read CONTRIBUTING.md .","title":"JSDoc"},{"location":"#installation-and-usage","text":"JSDoc supports stable versions of Node.js 8.15.0 and later. You can install JSDoc globally or in your project's node_modules folder. To install the latest version on npm globally (might require sudo ; learn how to fix this ): npm install -g jsdoc To install the latest version on npm locally and save it in your package's package.json file: npm install --save-dev jsdoc Note : By default, npm adds your package using the caret operator in front of the version number (for example, ^3.6.3 ). We recommend using the tilde operator instead (for example, ~3.6.3 ), which limits updates to the most recent patch-level version. See this Stack Overflow answer for more information about the caret and tilde operators. If you installed JSDoc locally, the JSDoc command-line tool is available in ./node_modules/.bin . To generate documentation for the file yourJavaScriptFile.js : ./node_modules/.bin/jsdoc yourJavaScriptFile.js If you installed JSDoc globally, run the jsdoc command: jsdoc yourJavaScriptFile.js By default, the generated documentation is saved in a directory named out . You can use the --destination ( -d ) option to specify another directory. Run jsdoc --help for a complete list of command-line options.","title":"Installation and Usage"},{"location":"#templates-and-tools","text":"The JSDoc community has created templates and other tools to help you generate and customize your documentation. Here are a few of them:","title":"Templates and tools"},{"location":"#templates","text":"jaguarjs-jsdoc DocStrap ( example ) jsdoc3Template ( example ) minami docdash ( example ) tui-jsdoc-template ( example ) better-docs ( example )","title":"Templates"},{"location":"#build-tools","text":"JSDoc Grunt plugin JSDoc Gulp plugin JSDoc GitHub Action","title":"Build tools"},{"location":"#other-tools","text":"jsdoc-to-markdown Integrating GitBook with JSDoc","title":"Other tools"},{"location":"#for-more-information","text":"Documentation is available at jsdoc.app . Contribute to the docs at jsdoc/jsdoc.github.io . Join JSDoc's Slack channel . Ask for help on the JSDoc Users mailing list . Post questions tagged jsdoc to Stack Overflow .","title":"For more information"},{"location":"#license","text":"JSDoc is copyright (c) 2011-present Michael Mathews micmath@gmail.com and the contributors to JSDoc . JSDoc is free software, licensed under the Apache License, Version 2.0. See the LICENSE file for more details.","title":"License"},{"location":"plugins-markdown/","text":"Overview JSDoc includes a Markdown plugin that automatically converts Markdown-formatted text to HTML. You can use this plugin with any JSDoc template. In JSDoc 3.2.2 and later, the Markdown plugin uses the marked Markdown parser . Note : When you enable the Markdown plugin, be sure to include a leading asterisk on each line of your JSDoc comments. If you omit the leading asterisks, JSDoc's parser may remove asterisks that are used for Markdown formatting. By default, JSDoc looks for Markdown-formatted text in the following JSDoc tags: @author @classdesc @description (including untagged descriptions at the start of a JSDoc comment) @param @property @returns @see @throws Enabling the Markdown plugin To enable the Markdown plugin, add the string plugins/markdown to the plugins array in your JSDoc configuration file : {% example \"JSON configuration file that enables the Markdown plugin\" %} { \"plugins\": [\"plugins/markdown\"] } {% endexample %} Converting Markdown in additional JSDoc tags By default, the Markdown plugin only processes specific JSDoc tags for Markdown text. You can handle Markdown text in other tags by adding a markdown.tags property to your JSDoc configuration file. The markdown.tags property contains an array of the additional doclet properties that can contain Markdown text. (In most cases, the name of the doclet property is the same as the tag name. However, some tags are stored differently; for example, the @param tag is stored in a doclet's params property. If you're not sure how a tag's text is stored in a doclet, run JSDoc with the -X/--explain tag, which prints each doclet to the console.) For example, if the foo and bar tags accept values that are stored in a doclet's foo and bar properties, you could enable Markdown processing of these tags by adding the following settings to your JSDoc configuration file: {% example \"Converting Markdown in 'foo' and 'bar' tags\" %} { \"plugins\": [\"plugins/markdown\"], \"markdown\": { \"tags\": [\"foo\", \"bar\"] } } {% endexample %} Excluding the default tags from Markdown processing To prevent the Markdown plugin from processing any of the default JSDoc tags , add a markdown.excludeTags property to your JSDoc configuration file. The markdown.excludeTags property contains an array of the default tags that should not be processed for Markdown text. For example, to exclude the author tag from Markdown processing: {% example \"Excluding the 'author' tag from Markdown processing\" %} { \"plugins\": [\"plugins/markdown\"], \"markdown\": { \"excludeTags\": [\"author\"] } } {% endexample %} Hard-wrapping text at line breaks By default, the Markdown plugin does not hard-wrap text at line breaks. This is because it's normal for a JSDoc comment to be wrapped across multiple lines. If you prefer to hard-wrap text at line breaks, set your JSDoc configuration file's markdown.hardwrap property to true . This property is available in JSDoc 3.4.0 and later. Adding ID attributes to headings By default, the Markdown plugin does not add an id attribute to each HTML heading. To automatically add id attributes based on the heading's text, set your JSDoc configuration file's markdown.idInHeadings property to true . This property is available in JSDoc 3.4.0 and later.","title":"Using the Markdown plugin"},{"location":"plugins-markdown/#overview","text":"JSDoc includes a Markdown plugin that automatically converts Markdown-formatted text to HTML. You can use this plugin with any JSDoc template. In JSDoc 3.2.2 and later, the Markdown plugin uses the marked Markdown parser . Note : When you enable the Markdown plugin, be sure to include a leading asterisk on each line of your JSDoc comments. If you omit the leading asterisks, JSDoc's parser may remove asterisks that are used for Markdown formatting. By default, JSDoc looks for Markdown-formatted text in the following JSDoc tags: @author @classdesc @description (including untagged descriptions at the start of a JSDoc comment) @param @property @returns @see @throws","title":"Overview"},{"location":"plugins-markdown/#enabling-the-markdown-plugin","text":"To enable the Markdown plugin, add the string plugins/markdown to the plugins array in your JSDoc configuration file : {% example \"JSON configuration file that enables the Markdown plugin\" %} { \"plugins\": [\"plugins/markdown\"] } {% endexample %}","title":"Enabling the Markdown plugin"},{"location":"plugins-markdown/#converting-markdown-in-additional-jsdoc-tags","text":"By default, the Markdown plugin only processes specific JSDoc tags for Markdown text. You can handle Markdown text in other tags by adding a markdown.tags property to your JSDoc configuration file. The markdown.tags property contains an array of the additional doclet properties that can contain Markdown text. (In most cases, the name of the doclet property is the same as the tag name. However, some tags are stored differently; for example, the @param tag is stored in a doclet's params property. If you're not sure how a tag's text is stored in a doclet, run JSDoc with the -X/--explain tag, which prints each doclet to the console.) For example, if the foo and bar tags accept values that are stored in a doclet's foo and bar properties, you could enable Markdown processing of these tags by adding the following settings to your JSDoc configuration file: {% example \"Converting Markdown in 'foo' and 'bar' tags\" %} { \"plugins\": [\"plugins/markdown\"], \"markdown\": { \"tags\": [\"foo\", \"bar\"] } } {% endexample %}","title":"Converting Markdown in additional JSDoc tags"},{"location":"plugins-markdown/#excluding-the-default-tags-from-markdown-processing","text":"To prevent the Markdown plugin from processing any of the default JSDoc tags , add a markdown.excludeTags property to your JSDoc configuration file. The markdown.excludeTags property contains an array of the default tags that should not be processed for Markdown text. For example, to exclude the author tag from Markdown processing: {% example \"Excluding the 'author' tag from Markdown processing\" %} { \"plugins\": [\"plugins/markdown\"], \"markdown\": { \"excludeTags\": [\"author\"] } } {% endexample %}","title":"Excluding the default tags from Markdown processing"},{"location":"plugins-markdown/#hard-wrapping-text-at-line-breaks","text":"By default, the Markdown plugin does not hard-wrap text at line breaks. This is because it's normal for a JSDoc comment to be wrapped across multiple lines. If you prefer to hard-wrap text at line breaks, set your JSDoc configuration file's markdown.hardwrap property to true . This property is available in JSDoc 3.4.0 and later.","title":"Hard-wrapping text at line breaks"},{"location":"plugins-markdown/#adding-id-attributes-to-headings","text":"By default, the Markdown plugin does not add an id attribute to each HTML heading. To automatically add id attributes based on the heading's text, set your JSDoc configuration file's markdown.idInHeadings property to true . This property is available in JSDoc 3.4.0 and later.","title":"Adding ID attributes to headings"},{"location":"about/CONTRIBUTING/","text":"Pull Requests If you're thinking about making some changes, maybe fixing a bug, or adding a snazzy new feature, first, thank you. Contributions are very welcome. Things need to be manageable for the maintainers, however. So below you'll find The fastest way to get your pull request merged in. Some things, particularly how you set up your branches and work with git, are just suggestions, but pretty good ones. Create a remote to track the base jsdoc/jsdoc repository This is just a convenience to make it easier to update your <tracking branch> (more on that shortly). You would execute something like: git remote add base git://github.com/jsdoc/jsdoc.git Here 'base' is the name of the remote. Feel free to use whatever you want. Set up a tracking branch for the base repository We're gonna call this your <tracking branch> . You will only ever update this branch by pulling from the 'base' remote. (as opposed to 'origin') git branch --track pullpost base/master git checkout pullpost Here 'pullpost' is the name of the branch. Fell free to use whatever you want. Create your change branch Once you are in <tracking branch> , make sure it's up to date, then create a branch for your changes off of that one. git branch fix-for-issue-395 git checkout fix-for-issue-395 Here 'fix-for-issue-395' is the name of the branch. Feel free to use whatever you want. We'll call this the <change branch> . This is the branch that you will eventually issue your pull request from. The purpose of these first three steps is to make sure that your merge request has a nice clean diff that only involves the changes related to your fix/feature. Make your changes On your <change branch> make any changes relevant to your fix/feature. Don't group fixes for multiple unrelated issues or multiple unrelated features together. Create a separate branch for each unrelated changeset. For instance, if you're fixing a bug in the parser and adding some new UI to the default template, those should be separate branches and merge requests. Add tests Add tests for your change. If you are submitting a bugfix, include a test that verifies the existence of the bug along with your fix. If you are submitting a new feature, include tests that verify proper feature function, if applicable. See the readme in the 'test' directory for more information Commit and publish Commit your changes and publish your branch (or push it if it's already published) Issue your pull request On github.com, switch to your <change branch> and click the 'Pull Request' button. Enter some meaningful information about the pull request. If it's a bugfix, that doesn't already have an issue associated with it, provide some info on what situations that bug occurs in and a sense of it's severity. If it does already have an issue, make sure the include the hash and issue number (e.g. '#100') so github links it. If it's a feature, provide some context about the motivations behind the feature, why it's important/useful/cool/necessary and what it does/how it works. Don't worry about being too verbose. Folks will be much more amenable to reading through your code if they know what its supposed to be about.","title":"CONTRIBUTING"},{"location":"about/CONTRIBUTING/#pull-requests","text":"If you're thinking about making some changes, maybe fixing a bug, or adding a snazzy new feature, first, thank you. Contributions are very welcome. Things need to be manageable for the maintainers, however. So below you'll find The fastest way to get your pull request merged in. Some things, particularly how you set up your branches and work with git, are just suggestions, but pretty good ones. Create a remote to track the base jsdoc/jsdoc repository This is just a convenience to make it easier to update your <tracking branch> (more on that shortly). You would execute something like: git remote add base git://github.com/jsdoc/jsdoc.git Here 'base' is the name of the remote. Feel free to use whatever you want. Set up a tracking branch for the base repository We're gonna call this your <tracking branch> . You will only ever update this branch by pulling from the 'base' remote. (as opposed to 'origin') git branch --track pullpost base/master git checkout pullpost Here 'pullpost' is the name of the branch. Fell free to use whatever you want. Create your change branch Once you are in <tracking branch> , make sure it's up to date, then create a branch for your changes off of that one. git branch fix-for-issue-395 git checkout fix-for-issue-395 Here 'fix-for-issue-395' is the name of the branch. Feel free to use whatever you want. We'll call this the <change branch> . This is the branch that you will eventually issue your pull request from. The purpose of these first three steps is to make sure that your merge request has a nice clean diff that only involves the changes related to your fix/feature. Make your changes On your <change branch> make any changes relevant to your fix/feature. Don't group fixes for multiple unrelated issues or multiple unrelated features together. Create a separate branch for each unrelated changeset. For instance, if you're fixing a bug in the parser and adding some new UI to the default template, those should be separate branches and merge requests. Add tests Add tests for your change. If you are submitting a bugfix, include a test that verifies the existence of the bug along with your fix. If you are submitting a new feature, include tests that verify proper feature function, if applicable. See the readme in the 'test' directory for more information Commit and publish Commit your changes and publish your branch (or push it if it's already published) Issue your pull request On github.com, switch to your <change branch> and click the 'Pull Request' button. Enter some meaningful information about the pull request. If it's a bugfix, that doesn't already have an issue associated with it, provide some info on what situations that bug occurs in and a sense of it's severity. If it does already have an issue, make sure the include the hash and issue number (e.g. '#100') so github links it. If it's a feature, provide some context about the motivations behind the feature, why it's important/useful/cool/necessary and what it does/how it works. Don't worry about being too verbose. Folks will be much more amenable to reading through your code if they know what its supposed to be about.","title":"Pull Requests"},{"location":"about/block-inline-tags/","text":"Overview JSDoc supports two different kinds of tags: Block tags , which are at the top level of a JSDoc comment. Inline tags , which are within the text of a block tag or a description. Block tags usually provide detailed information about your code, such as the parameters that a function accepts. Inline tags usually link to other parts of the documentation, similar to the anchor tag ( <a> ) in HTML. Block tags always begin with an at sign ( @ ). Each block tag must be followed by a line break, with the exception of the last block tag in a JSDoc comment. Inline tags also begin with an at sign. However, inline tags and their text must be enclosed in curly braces ( { and } ). The { denotes the start of the inline tag, and the } denotes the end of the inline tag. If your tag's text includes a closing curly brace ( } ), you must escape it with a leading backslash ( \\ ). You do not need to use a line break after inline tags. Most JSDoc tags are block tags. In general, when this site refers to \"JSDoc tags,\" we really mean \"block tags.\" Examples In the following example, @param is a block tag, and {@link} is an inline tag: {% example \"Block and inline tags in JSDoc comments\" %} /** * Set the shoe's color. Use {@link Shoe#setSize} to set the shoe size. * * @param {string} color - The shoe's color. */ Shoe.prototype.setColor = function(color) { // ... }; {% endexample %} You can use inline tags within a description, as shown above, or within a block tag, as shown below: {% example \"Inline tag used within a block tag\" %} /** * Set the shoe's color. * * @param {SHOE_COLORS} color - The shoe color. Must be an enumerated * value of {@link SHOE_COLORS}. */ Shoe.prototype.setColor = function(color) { // ... }; {% endexample %} When you use multiple block tags in a JSDoc comment, they must be separated by line breaks: {% example \"Multiple block tags separated by line breaks\" %} /** * Set the color and type of the shoelaces. * * @param {LACE_COLORS} color - The shoelace color. * @param {LACE_TYPES} type - The type of shoelace. */ Shoe.prototype.setLaceType = function(color, type) { // ... }; {% endexample %}","title":"Block and inline tags"},{"location":"about/block-inline-tags/#overview","text":"JSDoc supports two different kinds of tags: Block tags , which are at the top level of a JSDoc comment. Inline tags , which are within the text of a block tag or a description. Block tags usually provide detailed information about your code, such as the parameters that a function accepts. Inline tags usually link to other parts of the documentation, similar to the anchor tag ( <a> ) in HTML. Block tags always begin with an at sign ( @ ). Each block tag must be followed by a line break, with the exception of the last block tag in a JSDoc comment. Inline tags also begin with an at sign. However, inline tags and their text must be enclosed in curly braces ( { and } ). The { denotes the start of the inline tag, and the } denotes the end of the inline tag. If your tag's text includes a closing curly brace ( } ), you must escape it with a leading backslash ( \\ ). You do not need to use a line break after inline tags. Most JSDoc tags are block tags. In general, when this site refers to \"JSDoc tags,\" we really mean \"block tags.\"","title":"Overview"},{"location":"about/block-inline-tags/#examples","text":"In the following example, @param is a block tag, and {@link} is an inline tag: {% example \"Block and inline tags in JSDoc comments\" %} /** * Set the shoe's color. Use {@link Shoe#setSize} to set the shoe size. * * @param {string} color - The shoe's color. */ Shoe.prototype.setColor = function(color) { // ... }; {% endexample %} You can use inline tags within a description, as shown above, or within a block tag, as shown below: {% example \"Inline tag used within a block tag\" %} /** * Set the shoe's color. * * @param {SHOE_COLORS} color - The shoe color. Must be an enumerated * value of {@link SHOE_COLORS}. */ Shoe.prototype.setColor = function(color) { // ... }; {% endexample %} When you use multiple block tags in a JSDoc comment, they must be separated by line breaks: {% example \"Multiple block tags separated by line breaks\" %} /** * Set the color and type of the shoelaces. * * @param {LACE_COLORS} color - The shoelace color. * @param {LACE_TYPES} type - The type of shoelace. */ Shoe.prototype.setLaceType = function(color, type) { // ... }; {% endexample %}","title":"Examples"},{"location":"about/commandline/","text":"At its most basic level, JSDoc is used like so: /path/to/jsdoc yourSourceCodeFile.js anotherSourceCodeFile.js ... where ... are paths to other files to generate documentation for. Additionally, one may provide the path to a Markdown file (ending in \".md\") or a file named \"README\", and this will be added to the documentation on the front page. See these instructions . JSDoc supports a number of command-line options, many of which have both long and short forms. Alternatively, the command-line options may be specified in a configuration file given to JSDoc. The command-line options are: Option Description -a <value> , --access <value> Only display symbols with the given access property: private , protected , public , or undefined , or all for all access levels. By default, all except private symbols are shown. -c <value> , --configure <value> The path to a JSDoc configuration file . Defaults to conf.json or conf.json.EXAMPLE in the directory where JSDoc is installed. -d <value> , --destination <value> The path to the output folder for the generated documentation. For JSDoc's built-in Haruki template, use console to dump data to the console. Defaults to ./out . --debug Log information that can help debug issues in JSDoc itself. -e <value> , --encoding <value> Assume this encoding when reading all source files. Defaults to utf8 . -h , --help Display information about JSDoc's command-line options, then exit. --match <value> Only run tests whose names contain value . --nocolor When running tests, do not use color in the console output. On Windows, this option is enabled by default. -p , --private Include symbols marked with the @private tag in the generated documentation. By default, private symbols are not included. -P , --package The package.json file that contains the project name, version, and other details. Defaults to the first package.json file found in the source paths. --pedantic Treat errors as fatal errors, and treat warnings as errors. Defaults to false . -q <value> , --query <value> A query string to parse and store in the global variable env.opts.query . Example: foo=bar&baz=true . -r , --recurse Recurse into subdirectories when scanning for source files and tutorials. -R , --readme The README.md file to include in the generated documentation. Defaults to the first README.md file found in the source paths. -t <value> , --template <value> The path to the template to use for generating output. Defaults to templates/default , JSDoc's built-in default template. -T , --test Run JSDoc's test suite, and print the results to the console. -u <value> , --tutorials <value> Directory in which JSDoc should search for tutorials. If omitted, no tutorial pages will be generated. See the tutorial instructions for more information. -v , --version Displays JSDoc's version number, then exits. --verbose Log detailed information to the console as JSDoc runs. Defaults to false . -X , --explain Dump all doclets to the console in JSON format, then exit. Examples Generate documentation for files in the ./src directory, using the configuration file /path/to/my/conf.json , and save the output in the ./docs directory: {% example %} /path/to/jsdoc src -r -c /path/to/my/conf.json -d docs {% endexample %} Run all JSDoc tests whose names include the word tag , and log information about each test: {% example %} /path/to/jsdoc -T --match tag --verbose {% endexample %}","title":"Command-line arguments to JSDoc"},{"location":"about/commandline/#examples","text":"Generate documentation for files in the ./src directory, using the configuration file /path/to/my/conf.json , and save the output in the ./docs directory: {% example %} /path/to/jsdoc src -r -c /path/to/my/conf.json -d docs {% endexample %} Run all JSDoc tests whose names include the word tag , and log information about each test: {% example %} /path/to/jsdoc -T --match tag --verbose {% endexample %}","title":"Examples"},{"location":"about/configuring-default-template/","text":"JSDoc's default template provides several options that you can use to customize the appearance and content of generated documentation. To use these options, you must create a configuration file for JSDoc and set the appropriate options in the configuration file. Generating pretty-printed source files By default, JSDoc's default template generates pretty-printed versions of your source files. It also links to these pretty-printed files in the documentation. To disable pretty-printed files, set the option templates.default.outputSourceFiles to false . Using this option also removes links to your source files from the documentation. This option is available in JSDoc 3.3.0 and later. Copying static files to the output directory JSDoc's default template automatically copies a few static files, such as CSS stylesheets, to the output directory. In JSDoc 3.3.0 and later, you can tell the default template to copy additional static files to the output directory. For example, you might want to copy a directory of images to the output directory so you can display these images in your documentation. To copy additional static files to the output directory, use the following options: templates.default.staticFiles.include : An array of paths whose contents should be copied to the output directory. Subdirectories will be copied as well. templates.default.staticFiles.exclude : An array of paths that should not be copied to the output directory. templates.default.staticFiles.includePattern : A regular expression indicating which files to copy. If this property is not defined, all files will be copied. templates.default.staticFiles.excludePattern : A regular expression indicating which files to skip. If this property is not defined, nothing will be skipped. {% example \"Copying a directory of images to the output directory\" %} To copy all of the static files in ./myproject/static to the output directory: { \"templates\": { \"default\": { \"staticFiles\": { \"include\": [ \"./myproject/static\" ] } } } } If your static files directory contains the file ./myproject/static/img/screen.png , you can display the image in your docs by using the HTML tag <img src=\"img/screen.png\"> . {% endexample %} Showing the current date in the page footer By default, JSDoc's default template always shows the current date in the footer of the generated documentation. In JSDoc 3.3.0 and later, you can omit the current date by setting the option templates.default.includeDate to false . Showing longnames in the navigation column By default, JSDoc's default template shows a shortened version of each symbol's name in the navigation column. For example, the symbol my.namespace.MyClass would be displayed simply as MyClass . To show the complete longname instead, set the option templates.default.useLongnameInNav to true . This option is available in JSDoc 3.4.0 and later. Overriding the default template's layout file The default template uses a file named layout.tmpl to specify the header and footer for each page in the generated documentation. In particular, this file defines which CSS and JavaScript files are loaded for each page. In JSDoc 3.3.0 and later, you can specify your own layout.tmpl file to use, which allows you to load your own custom CSS and JavaScript files in addition to, or instead of, the standard files. To use this feature, set the option templates.default.layoutFile to the path to your customized layout file. Relative paths are resolved against the current working directory; the path to the configuration file; and the JSDoc directory, in that order.","title":"Configuring JSDoc's default template"},{"location":"about/configuring-default-template/#generating-pretty-printed-source-files","text":"By default, JSDoc's default template generates pretty-printed versions of your source files. It also links to these pretty-printed files in the documentation. To disable pretty-printed files, set the option templates.default.outputSourceFiles to false . Using this option also removes links to your source files from the documentation. This option is available in JSDoc 3.3.0 and later.","title":"Generating pretty-printed source files"},{"location":"about/configuring-default-template/#copying-static-files-to-the-output-directory","text":"JSDoc's default template automatically copies a few static files, such as CSS stylesheets, to the output directory. In JSDoc 3.3.0 and later, you can tell the default template to copy additional static files to the output directory. For example, you might want to copy a directory of images to the output directory so you can display these images in your documentation. To copy additional static files to the output directory, use the following options: templates.default.staticFiles.include : An array of paths whose contents should be copied to the output directory. Subdirectories will be copied as well. templates.default.staticFiles.exclude : An array of paths that should not be copied to the output directory. templates.default.staticFiles.includePattern : A regular expression indicating which files to copy. If this property is not defined, all files will be copied. templates.default.staticFiles.excludePattern : A regular expression indicating which files to skip. If this property is not defined, nothing will be skipped. {% example \"Copying a directory of images to the output directory\" %} To copy all of the static files in ./myproject/static to the output directory: { \"templates\": { \"default\": { \"staticFiles\": { \"include\": [ \"./myproject/static\" ] } } } } If your static files directory contains the file ./myproject/static/img/screen.png , you can display the image in your docs by using the HTML tag <img src=\"img/screen.png\"> . {% endexample %}","title":"Copying static files to the output directory"},{"location":"about/configuring-default-template/#showing-the-current-date-in-the-page-footer","text":"By default, JSDoc's default template always shows the current date in the footer of the generated documentation. In JSDoc 3.3.0 and later, you can omit the current date by setting the option templates.default.includeDate to false .","title":"Showing the current date in the page footer"},{"location":"about/configuring-default-template/#showing-longnames-in-the-navigation-column","text":"By default, JSDoc's default template shows a shortened version of each symbol's name in the navigation column. For example, the symbol my.namespace.MyClass would be displayed simply as MyClass . To show the complete longname instead, set the option templates.default.useLongnameInNav to true . This option is available in JSDoc 3.4.0 and later.","title":"Showing longnames in the navigation column"},{"location":"about/configuring-default-template/#overriding-the-default-templates-layout-file","text":"The default template uses a file named layout.tmpl to specify the header and footer for each page in the generated documentation. In particular, this file defines which CSS and JavaScript files are loaded for each page. In JSDoc 3.3.0 and later, you can specify your own layout.tmpl file to use, which allows you to load your own custom CSS and JavaScript files in addition to, or instead of, the standard files. To use this feature, set the option templates.default.layoutFile to the path to your customized layout file. Relative paths are resolved against the current working directory; the path to the configuration file; and the JSDoc directory, in that order.","title":"Overriding the default template's layout file"},{"location":"about/configuring-jsdoc/","text":"Configuration file formats To customize JSDoc's behavior, you can provide a configuration file to JSDoc in one of the following formats: A JSON file. In JSDoc 3.3.0 and later, this file may include comments. A CommonJS module that exports a single configuration object. This format is supported in JSDoc 3.5.0 and later. To run JSDoc with a configuration file, use the -c command-line option (for example, jsdoc -c /path/to/conf.json or jsdoc -c /path/to/conf.js ). The following examples show a simple configuration file that enables JSDoc's Markdown plugin . JSDoc's configuration options are explained in detail in the following sections. {% example \"JSON configuration file\" %} { \"plugins\": [\"plugins/markdown\"] } {% endexample %} {% example \"JavaScript configuration file\" %} 'use strict'; module.exports = { plugins: ['plugins/markdown'] }; {% endexample %} For a more comprehensive example of a JSON configuration file, see the file conf.json.EXAMPLE . Default configuration options If you do not specify a configuration file, JSDoc uses the following configuration options: {% example %} { \"plugins\": [], \"recurseDepth\": 10, \"source\": { \"includePattern\": \".+\\\\.js(doc|x)?$\", \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\" }, \"sourceType\": \"module\", \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [\"jsdoc\",\"closure\"] }, \"templates\": { \"cleverLinks\": false, \"monospaceLinks\": false } } {% endexample %} This means: No plugins are loaded ( plugins ). If recursion is enabled with the -r command-line flag , JSDoc will search for files 10 levels deep ( recurseDepth ). Only files ending in .js , .jsdoc , and .jsx will be processed ( source.includePattern ). Any file starting with an underscore, or in a directory starting with an underscore, will be ignored ( source.excludePattern ). JSDoc supports code that uses ES2015 modules ( sourceType ). JSDoc allows you to use unrecognized tags ( tags.allowUnknownTags ). Both standard JSDoc tags and Closure Compiler tags are enabled ( tags.dictionaries ). Inline {@link} tags are rendered in plain text ( templates.cleverLinks , templates.monospaceLinks ). These options and others are explained in the following sections. Configuring plugins To enable plugins, add their paths (relative to the JSDoc folder) into the plugins array. For example, the following JSON configuration file will enable the Markdown plugin, which converts Markdown-formatted text to HTML, and the \"summarize\" plugin, which autogenerates a summary for each doclet: {% example \"JSON configuration file with plugins\" %} { \"plugins\": [ \"plugins/markdown\", \"plugins/summarize\" ] } {% endexample %} See the plugin reference for further information, and look in JSDoc's plugins directory for the plugins built into JSDoc. You can configure the Markdown plugin by adding a markdown object to your configuration file. See Configuring the Markdown Plugin for details. Specifying recursion depth The recurseDepth option controls how many levels deep JSDoc will recursively search for source files and tutorials. This option is available in JSDoc 3.5.0 and later. This option is used only if you also specify the -r command-line flag , which tells JSDoc to recursively search for input files. {% example %} { \"recurseDepth\": 10 } {% endexample %} Specifying input files The source set of options, in combination with paths given to JSDoc on the command line, determines the set of input files that JSDoc uses to generate documentation. {% example %} { \"source\": { \"include\": [ /* array of paths to files to generate documentation for */ ], \"exclude\": [ /* array of paths to exclude */ ], \"includePattern\": \".+\\\\.js(doc|x)?$\", \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\" } } {% endexample %} source.include : An optional array of paths that contain files for which JSDoc should generate documentation. The paths given to JSDoc on the command line are combined with these paths. You can use the -r command-line option to recurse into subdirectories. source.exclude : An optional array of paths that JSDoc should ignore. In JSDoc 3.3.0 and later, this array may include subdirectories of the paths in source.include . source.includePattern : An optional string, interpreted as a regular expression. If present, all filenames must match this regular expression to be processed by JSDoc. By default, this option is set to \".+\\.js(doc|x)?$\", meaning that only files with the extensions .js , .jsdoc , and .jsx will be processed. source.excludePattern : An optional string, interpreted as a regular expression. If present, any file matching this regular expression will be ignored. By default, this option is set so that files beginning with an underscore (or anything under a directory beginning with an underscore) is ignored. These options are interpreted in the following order: Start with all paths given on the command line and in source.include . For each file found in Step 1, if the regular expression source.includePattern is present, the filename must match it, or it is ignored. For each file left from Step 2, if the regular expression source.excludePattern is present, any filename matching this regular expression is ignored. For each file left from Step 3, if the file's path is in source.exclude , it is ignored. All remaining files after these four steps are processed by JSDoc. As an example, suppose you have the following file structure: {% example %} myProject/ |- a.js |- b.js |- c.js |- _private | |- a.js |- lib/ |- a.js |- ignore.js |- d.txt {% endexample %} In addition, suppose your conf.json file looks like this example: {% example %} { \"source\": { \"include\": [\"myProject/a.js\", \"myProject/lib\", \"myProject/_private\"], \"exclude\": [\"myProject/lib/ignore.js\"], \"includePattern\": \".+\\\\.js(doc|x)?$\", \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\" } } {% endexample %} If you run jsdoc myProject/c.js -c /path/to/my/conf.json -r from the file containing the myProject folder, JSDoc will generate documentation for the following files: myProject/a.js myProject/c.js myProject/lib/a.js Here's why: Given source.include and the paths given on the command line, JSDoc starts off with these files: myProject/c.js (from the command line) myProject/a.js (from source.include ) myProject/lib/a.js , myProject/lib/ignore.js , myProject/lib/d.txt (from source.include and using the -r option) myProject/_private/a.js (from source.include ) JSDoc applies source.includePattern , leaving us with all of the above files except myProject/lib/d.txt , which does not end in .js , .jsdoc , or .jsx . JSDoc applies source.excludePattern , which removes myProject/_private/a.js . JSDoc applies source.exclude , which removes myProject/lib/ignore.js . Specifying the source type The sourceType option affects how JSDoc parses your JavaScript files. This option is available in JSDoc 3.5.0 and later. This option accepts the following values: module (default): Use this value for most types of JavaScript files. script : Use this value if JSDoc logs errors such as Delete of an unqualified identifier in strict mode when it parses your code. {% example %} { \"sourceType\": \"module\" } {% endexample %} Incorporating command-line options into the configuration file You can put many of JSDoc's command-line options into the configuration file instead of specifying them on the command line. To do this, add the long names of the relevant options into an opts section of the configuration file, with the value set to the option's value. {% example \"JSON configuration file with command-line options\" %} { \"opts\": { \"template\": \"templates/default\", // same as -t templates/default \"encoding\": \"utf8\", // same as -e utf8 \"destination\": \"./out/\", // same as -d ./out/ \"recurse\": true, // same as -r \"tutorials\": \"path/to/tutorials\", // same as -u path/to/tutorials } } {% endexample %} By using the source.include and opts options, you can put almost all of the arguments to JSDoc in a configuration file, so that the command line reduces to: jsdoc -c /path/to/conf.json When options are specified on the command line and in the configuration file, the command line takes precedence. Configuring tags and tag dictionaries The options in tags control which JSDoc tags are allowed and how each tag is interpreted. {% example %} { \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [\"jsdoc\",\"closure\"] } } {% endexample %} The tags.allowUnknownTags property affects how JSDoc handles unrecognized tags. If you set this option to false , and JSDoc finds a tag that it does not recognize (for example, @foo ), JSDoc logs a warning. By default, this option is set to true . In JSDoc 3.4.1 and later, you can also set this property to an array of tag names that JSDoc should allow (for example, [\"foo\",\"bar\"] ). The tags.dictionaries property controls which tags JSDoc recognizes, as well as how JSDoc interprets the tags that it recognizes. In JSDoc 3.3.0 and later, there are two built-in tag dictionaries: jsdoc : Core JSDoc tags. closure : Closure Compiler tags . By default, both dictionaries are enabled. Also, by default, the jsdoc dictionary is listed first; as a result, if the jsdoc dictionary handles a tag differently than the closure dictionary, the jsdoc version of the tag takes precedence. If you are using JSDoc with a Closure Compiler project, and you want to avoid using tags that Closure Compiler does not recognize, change the tags.dictionaries setting to [\"closure\"] . You can also change this setting to [\"closure\",\"jsdoc\"] if you want to allow core JSDoc tags, but you want to ensure that Closure Compiler-specific tags are interpreted as Closure Compiler would interpret them. Configuring templates The options in templates affect the appearance and content of generated documentation. Third-party templates may not implement all of these options. See Configuring JSDoc's Default Template for additional options that the default template supports. {% example %} { \"templates\": { \"cleverLinks\": false, \"monospaceLinks\": false } } {% endexample %} If templates.monospaceLinks is true, all link text from the inline {@link} tag will be rendered in monospace. If templates.cleverLinks is true, {@link asdf} will be rendered in normal font if asdf is a URL, and monospace otherwise. For example, {@link http://github.com} will render in plain text, but {@link MyNamespace.myFunction} will be in monospace. If templates.cleverLinks is true, templates.monospaceLinks is ignored.","title":"Configuring JSDoc with a configuration file"},{"location":"about/configuring-jsdoc/#configuration-file-formats","text":"To customize JSDoc's behavior, you can provide a configuration file to JSDoc in one of the following formats: A JSON file. In JSDoc 3.3.0 and later, this file may include comments. A CommonJS module that exports a single configuration object. This format is supported in JSDoc 3.5.0 and later. To run JSDoc with a configuration file, use the -c command-line option (for example, jsdoc -c /path/to/conf.json or jsdoc -c /path/to/conf.js ). The following examples show a simple configuration file that enables JSDoc's Markdown plugin . JSDoc's configuration options are explained in detail in the following sections. {% example \"JSON configuration file\" %} { \"plugins\": [\"plugins/markdown\"] } {% endexample %} {% example \"JavaScript configuration file\" %} 'use strict'; module.exports = { plugins: ['plugins/markdown'] }; {% endexample %} For a more comprehensive example of a JSON configuration file, see the file conf.json.EXAMPLE .","title":"Configuration file formats"},{"location":"about/configuring-jsdoc/#default-configuration-options","text":"If you do not specify a configuration file, JSDoc uses the following configuration options: {% example %} { \"plugins\": [], \"recurseDepth\": 10, \"source\": { \"includePattern\": \".+\\\\.js(doc|x)?$\", \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\" }, \"sourceType\": \"module\", \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [\"jsdoc\",\"closure\"] }, \"templates\": { \"cleverLinks\": false, \"monospaceLinks\": false } } {% endexample %} This means: No plugins are loaded ( plugins ). If recursion is enabled with the -r command-line flag , JSDoc will search for files 10 levels deep ( recurseDepth ). Only files ending in .js , .jsdoc , and .jsx will be processed ( source.includePattern ). Any file starting with an underscore, or in a directory starting with an underscore, will be ignored ( source.excludePattern ). JSDoc supports code that uses ES2015 modules ( sourceType ). JSDoc allows you to use unrecognized tags ( tags.allowUnknownTags ). Both standard JSDoc tags and Closure Compiler tags are enabled ( tags.dictionaries ). Inline {@link} tags are rendered in plain text ( templates.cleverLinks , templates.monospaceLinks ). These options and others are explained in the following sections.","title":"Default configuration options"},{"location":"about/configuring-jsdoc/#configuring-plugins","text":"To enable plugins, add their paths (relative to the JSDoc folder) into the plugins array. For example, the following JSON configuration file will enable the Markdown plugin, which converts Markdown-formatted text to HTML, and the \"summarize\" plugin, which autogenerates a summary for each doclet: {% example \"JSON configuration file with plugins\" %} { \"plugins\": [ \"plugins/markdown\", \"plugins/summarize\" ] } {% endexample %} See the plugin reference for further information, and look in JSDoc's plugins directory for the plugins built into JSDoc. You can configure the Markdown plugin by adding a markdown object to your configuration file. See Configuring the Markdown Plugin for details.","title":"Configuring plugins"},{"location":"about/configuring-jsdoc/#specifying-recursion-depth","text":"The recurseDepth option controls how many levels deep JSDoc will recursively search for source files and tutorials. This option is available in JSDoc 3.5.0 and later. This option is used only if you also specify the -r command-line flag , which tells JSDoc to recursively search for input files. {% example %} { \"recurseDepth\": 10 } {% endexample %}","title":"Specifying recursion depth"},{"location":"about/configuring-jsdoc/#specifying-input-files","text":"The source set of options, in combination with paths given to JSDoc on the command line, determines the set of input files that JSDoc uses to generate documentation. {% example %} { \"source\": { \"include\": [ /* array of paths to files to generate documentation for */ ], \"exclude\": [ /* array of paths to exclude */ ], \"includePattern\": \".+\\\\.js(doc|x)?$\", \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\" } } {% endexample %} source.include : An optional array of paths that contain files for which JSDoc should generate documentation. The paths given to JSDoc on the command line are combined with these paths. You can use the -r command-line option to recurse into subdirectories. source.exclude : An optional array of paths that JSDoc should ignore. In JSDoc 3.3.0 and later, this array may include subdirectories of the paths in source.include . source.includePattern : An optional string, interpreted as a regular expression. If present, all filenames must match this regular expression to be processed by JSDoc. By default, this option is set to \".+\\.js(doc|x)?$\", meaning that only files with the extensions .js , .jsdoc , and .jsx will be processed. source.excludePattern : An optional string, interpreted as a regular expression. If present, any file matching this regular expression will be ignored. By default, this option is set so that files beginning with an underscore (or anything under a directory beginning with an underscore) is ignored. These options are interpreted in the following order: Start with all paths given on the command line and in source.include . For each file found in Step 1, if the regular expression source.includePattern is present, the filename must match it, or it is ignored. For each file left from Step 2, if the regular expression source.excludePattern is present, any filename matching this regular expression is ignored. For each file left from Step 3, if the file's path is in source.exclude , it is ignored. All remaining files after these four steps are processed by JSDoc. As an example, suppose you have the following file structure: {% example %} myProject/ |- a.js |- b.js |- c.js |- _private | |- a.js |- lib/ |- a.js |- ignore.js |- d.txt {% endexample %} In addition, suppose your conf.json file looks like this example: {% example %} { \"source\": { \"include\": [\"myProject/a.js\", \"myProject/lib\", \"myProject/_private\"], \"exclude\": [\"myProject/lib/ignore.js\"], \"includePattern\": \".+\\\\.js(doc|x)?$\", \"excludePattern\": \"(^|\\\\/|\\\\\\\\)_\" } } {% endexample %} If you run jsdoc myProject/c.js -c /path/to/my/conf.json -r from the file containing the myProject folder, JSDoc will generate documentation for the following files: myProject/a.js myProject/c.js myProject/lib/a.js Here's why: Given source.include and the paths given on the command line, JSDoc starts off with these files: myProject/c.js (from the command line) myProject/a.js (from source.include ) myProject/lib/a.js , myProject/lib/ignore.js , myProject/lib/d.txt (from source.include and using the -r option) myProject/_private/a.js (from source.include ) JSDoc applies source.includePattern , leaving us with all of the above files except myProject/lib/d.txt , which does not end in .js , .jsdoc , or .jsx . JSDoc applies source.excludePattern , which removes myProject/_private/a.js . JSDoc applies source.exclude , which removes myProject/lib/ignore.js .","title":"Specifying input files"},{"location":"about/configuring-jsdoc/#specifying-the-source-type","text":"The sourceType option affects how JSDoc parses your JavaScript files. This option is available in JSDoc 3.5.0 and later. This option accepts the following values: module (default): Use this value for most types of JavaScript files. script : Use this value if JSDoc logs errors such as Delete of an unqualified identifier in strict mode when it parses your code. {% example %} { \"sourceType\": \"module\" } {% endexample %}","title":"Specifying the source type"},{"location":"about/configuring-jsdoc/#incorporating-command-line-options-into-the-configuration-file","text":"You can put many of JSDoc's command-line options into the configuration file instead of specifying them on the command line. To do this, add the long names of the relevant options into an opts section of the configuration file, with the value set to the option's value. {% example \"JSON configuration file with command-line options\" %} { \"opts\": { \"template\": \"templates/default\", // same as -t templates/default \"encoding\": \"utf8\", // same as -e utf8 \"destination\": \"./out/\", // same as -d ./out/ \"recurse\": true, // same as -r \"tutorials\": \"path/to/tutorials\", // same as -u path/to/tutorials } } {% endexample %} By using the source.include and opts options, you can put almost all of the arguments to JSDoc in a configuration file, so that the command line reduces to: jsdoc -c /path/to/conf.json When options are specified on the command line and in the configuration file, the command line takes precedence.","title":"Incorporating command-line options into the configuration file"},{"location":"about/configuring-jsdoc/#configuring-tags-and-tag-dictionaries","text":"The options in tags control which JSDoc tags are allowed and how each tag is interpreted. {% example %} { \"tags\": { \"allowUnknownTags\": true, \"dictionaries\": [\"jsdoc\",\"closure\"] } } {% endexample %} The tags.allowUnknownTags property affects how JSDoc handles unrecognized tags. If you set this option to false , and JSDoc finds a tag that it does not recognize (for example, @foo ), JSDoc logs a warning. By default, this option is set to true . In JSDoc 3.4.1 and later, you can also set this property to an array of tag names that JSDoc should allow (for example, [\"foo\",\"bar\"] ). The tags.dictionaries property controls which tags JSDoc recognizes, as well as how JSDoc interprets the tags that it recognizes. In JSDoc 3.3.0 and later, there are two built-in tag dictionaries: jsdoc : Core JSDoc tags. closure : Closure Compiler tags . By default, both dictionaries are enabled. Also, by default, the jsdoc dictionary is listed first; as a result, if the jsdoc dictionary handles a tag differently than the closure dictionary, the jsdoc version of the tag takes precedence. If you are using JSDoc with a Closure Compiler project, and you want to avoid using tags that Closure Compiler does not recognize, change the tags.dictionaries setting to [\"closure\"] . You can also change this setting to [\"closure\",\"jsdoc\"] if you want to allow core JSDoc tags, but you want to ensure that Closure Compiler-specific tags are interpreted as Closure Compiler would interpret them.","title":"Configuring tags and tag dictionaries"},{"location":"about/configuring-jsdoc/#configuring-templates","text":"The options in templates affect the appearance and content of generated documentation. Third-party templates may not implement all of these options. See Configuring JSDoc's Default Template for additional options that the default template supports. {% example %} { \"templates\": { \"cleverLinks\": false, \"monospaceLinks\": false } } {% endexample %} If templates.monospaceLinks is true, all link text from the inline {@link} tag will be rendered in monospace. If templates.cleverLinks is true, {@link asdf} will be rendered in normal font if asdf is a URL, and monospace otherwise. For example, {@link http://github.com} will render in plain text, but {@link MyNamespace.myFunction} will be in monospace. If templates.cleverLinks is true, templates.monospaceLinks is ignored.","title":"Configuring templates"},{"location":"about/getting-started/","text":"Getting started JSDoc 3 is an API documentation generator for JavaScript, similar to Javadoc or phpDocumentor. You add documentation comments directly to your source code, right alongside the code itself. The JSDoc tool will scan your source code and generate an HTML documentation website for you. Adding documentation comments to your code JSDoc's purpose is to document the API of your JavaScript application or library. It is assumed that you will want to document things like modules, namespaces, classes, methods, method parameters, and so on. JSDoc comments should generally be placed immediately before the code being documented. Each comment must start with a /** sequence in order to be recognized by the JSDoc parser. Comments beginning with /* , /*** , or more than 3 stars will be ignored. This is a feature to allow you to suppress parsing of comment blocks. {% example \"The simplest documentation is just a description\" %} /** This is a description of the foo function. */ function foo() { } {% endexample %} Adding a description is simple\u2014just type the description you want in the documentation comment. Special \"JSDoc tags\" can be used to give more information. For example, if the function is a constructor for a class, you can indicate this by adding a @constructor tag. {% example \"Use a JSDoc tag to describe your code\" %} /** * Represents a book. * @constructor */ function Book(title, author) { } {% endexample %} More tags can be used to add more information. See the home page for a complete list of tags that are recognized by JSDoc 3. {% example \"Adding more information with tags\" %} /** * Represents a book. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. */ function Book(title, author) { } {% endexample %} Generating a website Once your code is commented, you can use the JSDoc 3 tool to generate an HTML website from your source files. By default, JSDoc uses the built-in \"default\" template to turn the documentation into HTML. You can edit this template to suit your own needs or create an entirely new template if that is what you prefer. {% example \"Running the documentation generator on the command line\" %} jsdoc book.js {% endexample %} This command will create a directory named out/ in the current working directory. Within that directory, you will find the generated HTML pages.","title":"Getting Started with JSDoc 3"},{"location":"about/getting-started/#getting-started","text":"JSDoc 3 is an API documentation generator for JavaScript, similar to Javadoc or phpDocumentor. You add documentation comments directly to your source code, right alongside the code itself. The JSDoc tool will scan your source code and generate an HTML documentation website for you.","title":"Getting started"},{"location":"about/getting-started/#adding-documentation-comments-to-your-code","text":"JSDoc's purpose is to document the API of your JavaScript application or library. It is assumed that you will want to document things like modules, namespaces, classes, methods, method parameters, and so on. JSDoc comments should generally be placed immediately before the code being documented. Each comment must start with a /** sequence in order to be recognized by the JSDoc parser. Comments beginning with /* , /*** , or more than 3 stars will be ignored. This is a feature to allow you to suppress parsing of comment blocks. {% example \"The simplest documentation is just a description\" %} /** This is a description of the foo function. */ function foo() { } {% endexample %} Adding a description is simple\u2014just type the description you want in the documentation comment. Special \"JSDoc tags\" can be used to give more information. For example, if the function is a constructor for a class, you can indicate this by adding a @constructor tag. {% example \"Use a JSDoc tag to describe your code\" %} /** * Represents a book. * @constructor */ function Book(title, author) { } {% endexample %} More tags can be used to add more information. See the home page for a complete list of tags that are recognized by JSDoc 3. {% example \"Adding more information with tags\" %} /** * Represents a book. * @constructor * @param {string} title - The title of the book. * @param {string} author - The author of the book. */ function Book(title, author) { } {% endexample %}","title":"Adding documentation comments to your code"},{"location":"about/getting-started/#generating-a-website","text":"Once your code is commented, you can use the JSDoc 3 tool to generate an HTML website from your source files. By default, JSDoc uses the built-in \"default\" template to turn the documentation into HTML. You can edit this template to suit your own needs or create an entirely new template if that is what you prefer. {% example \"Running the documentation generator on the command line\" %} jsdoc book.js {% endexample %} This command will create a directory named out/ in the current working directory. Within that directory, you will find the generated HTML pages.","title":"Generating a website"},{"location":"about/including-package/","text":"Package files contain information that can be useful for your project's documentation, such as the project's name and version number. JSDoc can automatically use information from your project's package.json file when it generates documentation. For example, the default template shows the project's name and version number in the documentation. There are two ways to incorporate a package.json file into your documentation: In the source paths to your JavaScript files, include the path to a package.json file. JSDoc will use the first package.json file that it finds in your source paths. Run JSDoc with the -P/--package command-line option, specifying the path to your package.json file. This option is available in JSDoc 3.3.0 and later. The -P/--package command-line option takes precedence over your source paths. If you use the -P/--package command-line option, JSDoc will ignore any package.json files in your source paths. The package.json file must use npm's package format . Examples {% example \"Including a package file in your source paths\" %} jsdoc path/to/js path/to/package/package.json {% endexample %} {% example \"Using the -P/--package option\" %} jsdoc --package path/to/package/package-docs.json path/to/js {% endexample %}","title":"Including a Package File"},{"location":"about/including-package/#examples","text":"{% example \"Including a package file in your source paths\" %} jsdoc path/to/js path/to/package/package.json {% endexample %} {% example \"Using the -P/--package option\" %} jsdoc --package path/to/package/package-docs.json path/to/js {% endexample %}","title":"Examples"},{"location":"about/including-readme/","text":"There are two ways to incorporate a README file into your documentation: In the source paths to your JavaScript files, include the path to a Markdown file named README.md . JSDoc will use the first README.md file that it finds in your source paths. Run JSDoc with the -R/--readme command-line option, specifying the path to your README file. This option is available in JSDoc 3.3.0 and later. The README file may have any name and extension, but it must be in Markdown format. The -R/--readme command-line option takes precedence over your source paths. If you use the -R/--readme command-line option, JSDoc will ignore any README.md files in your source paths. If you are using JSDoc's default template, the README file's contents will be rendered in HTML in the generated documentation's index.html file. Examples {% example \"Including a README file in your source paths\" %} jsdoc path/to/js path/to/readme/README.md {% endexample %} {% example \"Using the -R/--readme option\" %} jsdoc --readme path/to/readme/README path/to/js {% endexample %}","title":"Including a README File"},{"location":"about/including-readme/#examples","text":"{% example \"Including a README file in your source paths\" %} jsdoc path/to/js path/to/readme/README.md {% endexample %} {% example \"Using the -R/--readme option\" %} jsdoc --readme path/to/readme/README path/to/js {% endexample %}","title":"Examples"},{"location":"about/license-jsdoc3/","text":"JSDoc 3 is free software, licensed under the Apache License, Version 2.0 . Commercial and non-commercial use are permitted in compliance with the License. In addition, JSDoc 3 includes or depends upon several third-party software packages, either in whole or in part. Each third-party software package is provided under its own license. See LICENSE.md for more details about licensing.","title":"License"},{"location":"about/namepaths/","text":"Namepaths in JSDoc 3 When referring to a JavaScript variable that is elsewhere in your documentation, you must provide a unique identifier that maps to that variable. A namepath provides a way to do so and disambiguate between instance members, static members and inner variables. {% example \"Basic Syntax Examples of Namepaths in JSDoc 3\" %} myFunction MyConstructor MyConstructor#instanceMember MyConstructor.staticMember MyConstructor~innerMember // note that JSDoc 2 uses a dash {% endexample %} The example below shows: an instance method named \"say,\" an inner function also named \"say,\" and a static method also named \"say.\" These are three distinct methods that all exist independently of one another. {% example \"Use a documentation tag to describe your code.\" %} /** @constructor */ Person = function() { this.say = function() { return \"I'm an instance.\"; } function say() { return \"I'm inner.\"; } } Person.say = function() { return \"I'm static.\"; } var p = new Person(); p.say(); // I'm an instance. Person.say(); // I'm static. // there is no way to directly access the inner function from here {% endexample %} You would use three different namepath syntaxes to refer to the three different methods: {% example \"Use a documentation tag to describe your code.\" %} Person#say // the instance method named \"say.\" Person.say // the static method named \"say.\" Person~say // the inner method named \"say.\" {% endexample %} You might wonder why there is a syntax to refer to an inner method when that method isn't directly accessible from outside the function it is defined in. While that is true, and thus the \"~\" syntax is rarely used, it is possible to return a reference to an inner method from another method inside that container, so it is possible that some object elsewhere in your code might borrow an inner method. Note that if a constructor has an instance member that is also a constructor, you can simply chain the namepaths together to form a longer namepath: {% example \"Use a documentation tag to describe your code.\" %} /** @constructor */ Person = function() { /** @constructor */ this.Idea = function() { this.consider = function(){ return \"hmmm\"; } } } var p = new Person(); var i = new p.Idea(); i.consider(); {% endexample %} In this case, to refer to the method named \"consider,\" you would use the following namepath: Person#Idea#consider This chaining can be used with any combination of the connecting symbols: # . ~ {% example \"Special cases: modules, externals and events.\" %} /** A module. Its name is module:foo/bar. * @module foo/bar */ /** The built in string object. Its name is external:String. * @external String */ /** An event. Its name is module:foo/bar.event:MyEvent. * @event module:foo/bar.event:MyEvent */ {% endexample %} There are some special cases with namepaths: @module names are prefixed by \"module:\", @external names are prefixed by \"external:\", and @event names are prefixed by \"event:\". {% example \"Namepaths of objects with special characters in the name.\" %} /** @namespace */ var chat = { /** * Refer to this by {@link chat.\"#channel\"}. * @namespace */ \"#channel\": { /** * Refer to this by {@link chat.\"#channel\".open}. * @type {boolean} * @defaultvalue */ open: true, /** * Internal quotes have to be escaped by backslash. This is * {@link chat.\"#channel\".\"say-\\\"hello\\\"\"}. */ 'say-\"hello\"': function (msg) {} } }; /** * Now we define an event in our {@link chat.\"#channel\"} namespace. * @event chat.\"#channel\".\"op:announce-motd\" */ {% endexample %} Above is an example of a namespace with \"unusual\" characters in its member names (the hash character, dashes, even quotes). To refer to these you just need quote the names: chat.\"#channel\", chat.\"#channel\".\"op:announce-motd\", and so on. Internal quotes in names should be escaped with backslashes: chat.\"#channel\".\"say-\\\"hello\\\"\".","title":"Using namepaths with JSDoc 3"},{"location":"about/namepaths/#namepaths-in-jsdoc-3","text":"When referring to a JavaScript variable that is elsewhere in your documentation, you must provide a unique identifier that maps to that variable. A namepath provides a way to do so and disambiguate between instance members, static members and inner variables. {% example \"Basic Syntax Examples of Namepaths in JSDoc 3\" %} myFunction MyConstructor MyConstructor#instanceMember MyConstructor.staticMember MyConstructor~innerMember // note that JSDoc 2 uses a dash {% endexample %} The example below shows: an instance method named \"say,\" an inner function also named \"say,\" and a static method also named \"say.\" These are three distinct methods that all exist independently of one another. {% example \"Use a documentation tag to describe your code.\" %} /** @constructor */ Person = function() { this.say = function() { return \"I'm an instance.\"; } function say() { return \"I'm inner.\"; } } Person.say = function() { return \"I'm static.\"; } var p = new Person(); p.say(); // I'm an instance. Person.say(); // I'm static. // there is no way to directly access the inner function from here {% endexample %} You would use three different namepath syntaxes to refer to the three different methods: {% example \"Use a documentation tag to describe your code.\" %} Person#say // the instance method named \"say.\" Person.say // the static method named \"say.\" Person~say // the inner method named \"say.\" {% endexample %} You might wonder why there is a syntax to refer to an inner method when that method isn't directly accessible from outside the function it is defined in. While that is true, and thus the \"~\" syntax is rarely used, it is possible to return a reference to an inner method from another method inside that container, so it is possible that some object elsewhere in your code might borrow an inner method. Note that if a constructor has an instance member that is also a constructor, you can simply chain the namepaths together to form a longer namepath: {% example \"Use a documentation tag to describe your code.\" %} /** @constructor */ Person = function() { /** @constructor */ this.Idea = function() { this.consider = function(){ return \"hmmm\"; } } } var p = new Person(); var i = new p.Idea(); i.consider(); {% endexample %} In this case, to refer to the method named \"consider,\" you would use the following namepath: Person#Idea#consider This chaining can be used with any combination of the connecting symbols: # . ~ {% example \"Special cases: modules, externals and events.\" %} /** A module. Its name is module:foo/bar. * @module foo/bar */ /** The built in string object. Its name is external:String. * @external String */ /** An event. Its name is module:foo/bar.event:MyEvent. * @event module:foo/bar.event:MyEvent */ {% endexample %} There are some special cases with namepaths: @module names are prefixed by \"module:\", @external names are prefixed by \"external:\", and @event names are prefixed by \"event:\". {% example \"Namepaths of objects with special characters in the name.\" %} /** @namespace */ var chat = { /** * Refer to this by {@link chat.\"#channel\"}. * @namespace */ \"#channel\": { /** * Refer to this by {@link chat.\"#channel\".open}. * @type {boolean} * @defaultvalue */ open: true, /** * Internal quotes have to be escaped by backslash. This is * {@link chat.\"#channel\".\"say-\\\"hello\\\"\"}. */ 'say-\"hello\"': function (msg) {} } }; /** * Now we define an event in our {@link chat.\"#channel\"} namespace. * @event chat.\"#channel\".\"op:announce-motd\" */ {% endexample %} Above is an example of a namespace with \"unusual\" characters in its member names (the hash character, dashes, even quotes). To refer to these you just need quote the names: chat.\"#channel\", chat.\"#channel\".\"op:announce-motd\", and so on. Internal quotes in names should be escaped with backslashes: chat.\"#channel\".\"say-\\\"hello\\\"\".","title":"Namepaths in JSDoc 3"},{"location":"about/plugins/","text":"Creating and Enabling a Plugin There are two steps required to create and enable a new JSDoc plugin: Create a JavaScript module to contain your plugin code. Include that module in the plugins array of JSDoc's configuration file . You can specify an absolute or relative path. If you use a relative path, JSDoc searches for the plugin in the current working directory; the directory where the configuration file is located; and the JSDoc directory, in that order. For example, if your plugin is defined in the plugins/shout.js file in the current working directory, you would add the string plugins/shout to the plugins array in your JSDoc configuration file: {% example \"Adding a plugin to JSDoc's configuration file\" %} { \"plugins\": [\"plugins/shout\"] } {% endexample %} JSDoc executes plugins in the order that they are listed in the configuration file. Authoring JSDoc 3 Plugins JSDoc 3's plugin system offers extensive control over the parsing process. A plugin can affect the parse results by doing any of the following: Defining event handlers Defining tags Defining a visitor for abstract syntax tree nodes Event Handlers At the highest level, a plugin may register handlers for specific named events that JSDoc fires. JSDoc will pass an event object to the handler. Your plugin module should export a handlers object that contains your handler, like so: {% example \"Event-handler plugin for 'newDoclet' events\" %} exports.handlers = { newDoclet: function(e) { // Do something when we see a new doclet } }; {% endexample %} JSDoc fires events in the same order as the underlying code. An event-handler plugin can stop later plugins from running by setting a stopPropagation property on the event object ( e.stopPropagation = true ). A plugin can stop the event from firing by setting a preventDefault property ( e.preventDefault = true ). Event: parseBegin The parseBegin event is fired before JSDoc starts loading and parsing the source files. Your plugin can control which files JSDoc will parse by modifying the event's contents. Note : This event is fired in JSDoc 3.2 and later. The event object contains the following properties: sourcefiles : An array of paths to source files that will be parsed. Event: fileBegin The fileBegin event is fired when the parser is about to parse a file. Your plugin can use this event to trigger per-file initialization if necessary. The event object contains the following properties: filename : The name of the file. Event: beforeParse The beforeParse event is fired before parsing has begun. Plugins can use this method to modify the source code that will be parsed. For instance, your plugin could add a JSDoc comment, or it could remove preprocessing tags that are not valid JavaScript. The event object contains the following properties: filename : The name of the file. source : The contents of the file. Below is an example that adds a virtual comment for a function to the source so that it will get parsed and added to the documentation. This might be done to document methods that will be available to users, but might not appear in the source code being documented, such as methods provided by an external superclass: {% example \"Example\" %} exports.handlers = { beforeParse: function(e) { var extraDoc = [ '/**', ' * Function provided by a superclass.', ' * @name superFunc', ' * @memberof ui.mywidget', ' * @function', ' */' ]; e.source += extraDoc.join('\\n'); } }; {% endexample %} Event: jsdocCommentFound The jsdocCommentFound event is fired whenever a JSDoc comment is found. The comment may or may not be associated with any code. You might use this event to modify the contents of a comment before it is processed. The event object contains the following properties: filename : The name of the file. comment : The text of the JSDoc comment. lineno : The line number on which the comment was found. columnno : The column number on which the comment was found. Available in JSDoc 3.5.0 and later. Event: symbolFound The symbolFound event is fired when the parser comes across a symbol in the code that may need to be documented. For example, the parser fires a symbolFound event for each variable, function, and object literal in a source file. The event object contains the following properties: filename : The name of the file. comment : The text of the comment associated with the symbol, if any. id : The unique ID of the symbol. lineno : The line number on which the symbol was found. columnno : The column number on which the symbol was found. Available in JSDoc 3.5.0 and later. range : An array containing the numeric index of the first and last characters in the source file that are associated with the symbol. astnode : The symbol's node from the abstract syntax tree. code : Object with detailed information about the code. This object usually contains name , type , and node properties. The object might also have value , paramnames , or funcscope properties depending on the symbol. Event: newDoclet The newDoclet event is the highest-level event. It is fired when a new doclet has been created. This means that a JSDoc comment or a symbol has been processed, and the actual doclet that will be passed to the template has been created. The event object contains the following properties: doclet : The new doclet that was created. The doclet's properties can vary depending on the comment or symbol that the doclet represents. Some common properties you're likely to see include: comment : The text of the JSDoc comment, or an empty string if the symbol is undocumented. meta : Object that describes how the doclet relates to the source file (for example, the location within the source file). description : A description of the symbol being documented. kind : The kind of symbol being documented (for example, class or function ). name : The short name for the symbol (for example, myMethod ). longname : The fully qualified name, including memberof info (for example, MyClass#myMethod ). memberof : The module, namespace, or class that this symbol belongs to (for example, MyClass ), or an empty string if the symbol does not have a parent. scope : The scope of the symbol within its parent (for example, global , static , instance , or inner ). undocumented : Set to true if the symbol did not have a JSDoc comment. defaultvalue : The default value for a symbol. type : Object containing details about the symbol's type. params : Object containing the list of parameters to a function. tags : Object containing a list of tags that JSDoc did not recognize. Only available if allowUnknownTags is set to true in JSDoc's configuration file. To see the doclets that JSDoc generates for your code, run JSDoc with the -X command-line option . Below is an example of a newDoclet handler that shouts the descriptions: {% example \"Example\" %} exports.handlers = { newDoclet: function(e) { // e.doclet will refer to the newly created doclet // you can read and modify properties of that doclet if you wish if (typeof e.doclet.description === 'string') { e.doclet.description = e.doclet.description.toUpperCase(); } } }; {% endexample %} Event: fileComplete The fileComplete event is fired when the parser has finished parsing a file. Your plugin could use this event to trigger per-file cleanup. The event object contains the following properties: filename : The name of the file. source : The contents of the file. Event: parseComplete The parseComplete event is fired after JSDoc has parsed all of the specified source files. Note : This event is fired in JSDoc 3.2 and later. The event object contains the following properties: sourcefiles : An array of paths to source files that were parsed. doclets : An array of doclet objects. See the newDoclet event for details about the properties that each doclet can contain. Available in JSDoc 3.2.1 and later. Event: processingComplete The processingComplete event is fired after JSDoc updates the parse results to reflect inherited and borrowed symbols. Note : This event is fired in JSDoc 3.2.1 and later. The event object contains the following properties: doclets : An array of doclet objects. See the newDoclet event for details about the properties that each doclet can contain. Tag Definitions Adding tags to the tag dictionary is a mid-level way to affect documentation generation. Before a newDoclet event is triggered, JSDoc comment blocks are parsed to determine the description and any JSDoc tags that may be present. When a tag is found, if it has been defined in the tag dictionary, it is given a chance to modify the doclet. Plugins can define tags by exporting a defineTags function. That function will be passed a dictionary that can be used to define tags, like so: {% example \"Example\" %} exports.defineTags = function(dictionary) { // define tags here }; {% endexample %} The Dictionary The dictionary provides the following methods: defineTag(title, opts) : Used to define tags. The first parameter is the name of the tag (for example, param or overview ). The second is an object containing options for the tag. You can include any of the following options; the default value for each option is false : canHaveType (boolean) : Set to true if the tag text can include a type expression (such as {string} in @param {string} name - Description ). canHaveName (boolean) : Set to true if the tag text can include a name (such as name in @param {string} name - Description ). isNamespace (boolean) : Set to true if the tag should be applied to the doclet's longname as a namespace. For example, the @module tag sets this option to true , and using the tag @module myModuleName results in the longname module:myModuleName . mustHaveValue (boolean) : Set to true if the tag must have a value (such as TheName in @name TheName ). mustNotHaveDescription (boolean) : Set to true if the tag may have a value but must not have a description (such as TheDescription in @tag {typeExpr} TheDescription ). mustNotHaveValue (boolean) : Set to true if the tag must not have a value. onTagged (function) : A callback function executed when the tag is found. The function is passed two parameters: the doclet and the tag object. lookUp(tagName) : Retrieve a tag object by name. Returns the tag object, including its options, or false if the tag is not defined. isNamespace(tagName) : Returns true if the tag is applied to a doclet's longname as a namespace. normalise(tagName) : Returns the canonical name of a tag. For example, the @const tag is a synonym for @constant ; as a result, if you call normalise('const') , it returns the string constant . normalize(tagName) : Synonym for normalise . Available in JSDoc 3.3.0 and later. A tag's onTagged callback can modify the contents of the doclet or tag. {% example \"Defining an onTagged callback\" %} dictionary.defineTag('instance', { onTagged: function(doclet, tag) { doclet.scope = \"instance\"; } }); {% endexample %} The defineTag method returns a Tag object, which has a synonym method that can be used to declare a synonym for the tag. {% example \"Defining a tag synonym\" %} dictionary.defineTag('exception', { /* options for exception tag */ }) .synonym('throws'); {% endexample %} Node Visitors At the lowest level, plugin authors can process each node in the abstract syntax tree (AST) by defining a node visitor that will visit each node. By using a node-visitor plugin, you can modify comments and trigger parser events for any arbitrary piece of code. Plugins can define a node visitor by exporting an astNodeVisitor object that contains a visitNode function, like so: {% example \"Example\" %} exports.astNodeVisitor = { visitNode: function(node, e, parser, currentSourceName) { // do all sorts of crazy things here } }; {% endexample %} The function is called on each node with the following parameters: node : The AST node. AST nodes are JavaScript objects that use the format defined by the ESTree spec . You can use AST Explorer to see the AST that will be created for your source code. As of version 3.5.0, JSDoc uses the current version of the Babylon parser with all plugins enabled. e : The event. If the node is one that the parser handles, the event object will already be populated with the same things described in the symbolFound event above. Otherwise, it will be an empty object on which to set various properties. parser : The JSDoc parser instance. currentSourceName : The name of the file being parsed. Making things happen The primary reasons to implement a node visitor are to be able to document things that aren't normally documented (like function calls that create classes) or to auto generate documentation for code that isn't documented. For instance, a plugin might look for calls to a _trigger method since it knows that means an event is fired and then generate documentation for the event. To make things happen, the visitNode function should modify properties of the event parameter. In general the goal is to construct a comment and then get an event to fire. After the parser lets all of the node visitors have a look at the node, it looks to see if the event object has a comment property and an event property. If it has both, the event named in the event property is fired. The event is usually symbolFound or jsdocCommentFound , but theoretically, a plugin could define its own events and handle them. As with event-handler plugins, a node-visitor plugin can stop later plugins from running by setting a stopPropagation property on the event object ( e.stopPropagation = true ). A plugin can stop the event from firing by setting a preventDefault property ( e.preventDefault = true ). Reporting Errors If your plugin needs to report an error, use one of the following methods in the jsdoc/util/logger module: logger.warn : Warn the user about a possible problem. logger.error : Report an error from which the plugin can recover. logger.fatal : Report an error that should cause JSDoc to stop running. Using these methods creates a better user experience than simply throwing an error. Note : Do not use the jsdoc/util/error module to report errors. This module is deprecated and will be removed in a future version of JSDoc. {% example \"Reporting a non-fatal error\" %} var logger = require('jsdoc/util/logger'); exports.handlers = { newDoclet: function(e) { // Your code here. if (somethingBadHappened) { logger.error('Oh, no, something bad happened!'); } } }; {% endexample %}","title":"About JSDoc plugins"},{"location":"about/plugins/#creating-and-enabling-a-plugin","text":"There are two steps required to create and enable a new JSDoc plugin: Create a JavaScript module to contain your plugin code. Include that module in the plugins array of JSDoc's configuration file . You can specify an absolute or relative path. If you use a relative path, JSDoc searches for the plugin in the current working directory; the directory where the configuration file is located; and the JSDoc directory, in that order. For example, if your plugin is defined in the plugins/shout.js file in the current working directory, you would add the string plugins/shout to the plugins array in your JSDoc configuration file: {% example \"Adding a plugin to JSDoc's configuration file\" %} { \"plugins\": [\"plugins/shout\"] } {% endexample %} JSDoc executes plugins in the order that they are listed in the configuration file.","title":"Creating and Enabling a Plugin"},{"location":"about/plugins/#authoring-jsdoc-3-plugins","text":"JSDoc 3's plugin system offers extensive control over the parsing process. A plugin can affect the parse results by doing any of the following: Defining event handlers Defining tags Defining a visitor for abstract syntax tree nodes","title":"Authoring JSDoc 3 Plugins"},{"location":"about/plugins/#event-handlers","text":"At the highest level, a plugin may register handlers for specific named events that JSDoc fires. JSDoc will pass an event object to the handler. Your plugin module should export a handlers object that contains your handler, like so: {% example \"Event-handler plugin for 'newDoclet' events\" %} exports.handlers = { newDoclet: function(e) { // Do something when we see a new doclet } }; {% endexample %} JSDoc fires events in the same order as the underlying code. An event-handler plugin can stop later plugins from running by setting a stopPropagation property on the event object ( e.stopPropagation = true ). A plugin can stop the event from firing by setting a preventDefault property ( e.preventDefault = true ).","title":"Event Handlers"},{"location":"about/plugins/#event-parsebegin","text":"The parseBegin event is fired before JSDoc starts loading and parsing the source files. Your plugin can control which files JSDoc will parse by modifying the event's contents. Note : This event is fired in JSDoc 3.2 and later. The event object contains the following properties: sourcefiles : An array of paths to source files that will be parsed.","title":"Event: parseBegin"},{"location":"about/plugins/#event-filebegin","text":"The fileBegin event is fired when the parser is about to parse a file. Your plugin can use this event to trigger per-file initialization if necessary. The event object contains the following properties: filename : The name of the file.","title":"Event: fileBegin"},{"location":"about/plugins/#event-beforeparse","text":"The beforeParse event is fired before parsing has begun. Plugins can use this method to modify the source code that will be parsed. For instance, your plugin could add a JSDoc comment, or it could remove preprocessing tags that are not valid JavaScript. The event object contains the following properties: filename : The name of the file. source : The contents of the file. Below is an example that adds a virtual comment for a function to the source so that it will get parsed and added to the documentation. This might be done to document methods that will be available to users, but might not appear in the source code being documented, such as methods provided by an external superclass: {% example \"Example\" %} exports.handlers = { beforeParse: function(e) { var extraDoc = [ '/**', ' * Function provided by a superclass.', ' * @name superFunc', ' * @memberof ui.mywidget', ' * @function', ' */' ]; e.source += extraDoc.join('\\n'); } }; {% endexample %}","title":"Event: beforeParse"},{"location":"about/plugins/#event-jsdoccommentfound","text":"The jsdocCommentFound event is fired whenever a JSDoc comment is found. The comment may or may not be associated with any code. You might use this event to modify the contents of a comment before it is processed. The event object contains the following properties: filename : The name of the file. comment : The text of the JSDoc comment. lineno : The line number on which the comment was found. columnno : The column number on which the comment was found. Available in JSDoc 3.5.0 and later.","title":"Event: jsdocCommentFound"},{"location":"about/plugins/#event-symbolfound","text":"The symbolFound event is fired when the parser comes across a symbol in the code that may need to be documented. For example, the parser fires a symbolFound event for each variable, function, and object literal in a source file. The event object contains the following properties: filename : The name of the file. comment : The text of the comment associated with the symbol, if any. id : The unique ID of the symbol. lineno : The line number on which the symbol was found. columnno : The column number on which the symbol was found. Available in JSDoc 3.5.0 and later. range : An array containing the numeric index of the first and last characters in the source file that are associated with the symbol. astnode : The symbol's node from the abstract syntax tree. code : Object with detailed information about the code. This object usually contains name , type , and node properties. The object might also have value , paramnames , or funcscope properties depending on the symbol.","title":"Event: symbolFound"},{"location":"about/plugins/#event-newdoclet","text":"The newDoclet event is the highest-level event. It is fired when a new doclet has been created. This means that a JSDoc comment or a symbol has been processed, and the actual doclet that will be passed to the template has been created. The event object contains the following properties: doclet : The new doclet that was created. The doclet's properties can vary depending on the comment or symbol that the doclet represents. Some common properties you're likely to see include: comment : The text of the JSDoc comment, or an empty string if the symbol is undocumented. meta : Object that describes how the doclet relates to the source file (for example, the location within the source file). description : A description of the symbol being documented. kind : The kind of symbol being documented (for example, class or function ). name : The short name for the symbol (for example, myMethod ). longname : The fully qualified name, including memberof info (for example, MyClass#myMethod ). memberof : The module, namespace, or class that this symbol belongs to (for example, MyClass ), or an empty string if the symbol does not have a parent. scope : The scope of the symbol within its parent (for example, global , static , instance , or inner ). undocumented : Set to true if the symbol did not have a JSDoc comment. defaultvalue : The default value for a symbol. type : Object containing details about the symbol's type. params : Object containing the list of parameters to a function. tags : Object containing a list of tags that JSDoc did not recognize. Only available if allowUnknownTags is set to true in JSDoc's configuration file. To see the doclets that JSDoc generates for your code, run JSDoc with the -X command-line option . Below is an example of a newDoclet handler that shouts the descriptions: {% example \"Example\" %} exports.handlers = { newDoclet: function(e) { // e.doclet will refer to the newly created doclet // you can read and modify properties of that doclet if you wish if (typeof e.doclet.description === 'string') { e.doclet.description = e.doclet.description.toUpperCase(); } } }; {% endexample %}","title":"Event: newDoclet"},{"location":"about/plugins/#event-filecomplete","text":"The fileComplete event is fired when the parser has finished parsing a file. Your plugin could use this event to trigger per-file cleanup. The event object contains the following properties: filename : The name of the file. source : The contents of the file.","title":"Event: fileComplete"},{"location":"about/plugins/#event-parsecomplete","text":"The parseComplete event is fired after JSDoc has parsed all of the specified source files. Note : This event is fired in JSDoc 3.2 and later. The event object contains the following properties: sourcefiles : An array of paths to source files that were parsed. doclets : An array of doclet objects. See the newDoclet event for details about the properties that each doclet can contain. Available in JSDoc 3.2.1 and later.","title":"Event: parseComplete"},{"location":"about/plugins/#event-processingcomplete","text":"The processingComplete event is fired after JSDoc updates the parse results to reflect inherited and borrowed symbols. Note : This event is fired in JSDoc 3.2.1 and later. The event object contains the following properties: doclets : An array of doclet objects. See the newDoclet event for details about the properties that each doclet can contain.","title":"Event: processingComplete"},{"location":"about/plugins/#tag-definitions","text":"Adding tags to the tag dictionary is a mid-level way to affect documentation generation. Before a newDoclet event is triggered, JSDoc comment blocks are parsed to determine the description and any JSDoc tags that may be present. When a tag is found, if it has been defined in the tag dictionary, it is given a chance to modify the doclet. Plugins can define tags by exporting a defineTags function. That function will be passed a dictionary that can be used to define tags, like so: {% example \"Example\" %} exports.defineTags = function(dictionary) { // define tags here }; {% endexample %}","title":"Tag Definitions"},{"location":"about/plugins/#the-dictionary","text":"The dictionary provides the following methods: defineTag(title, opts) : Used to define tags. The first parameter is the name of the tag (for example, param or overview ). The second is an object containing options for the tag. You can include any of the following options; the default value for each option is false : canHaveType (boolean) : Set to true if the tag text can include a type expression (such as {string} in @param {string} name - Description ). canHaveName (boolean) : Set to true if the tag text can include a name (such as name in @param {string} name - Description ). isNamespace (boolean) : Set to true if the tag should be applied to the doclet's longname as a namespace. For example, the @module tag sets this option to true , and using the tag @module myModuleName results in the longname module:myModuleName . mustHaveValue (boolean) : Set to true if the tag must have a value (such as TheName in @name TheName ). mustNotHaveDescription (boolean) : Set to true if the tag may have a value but must not have a description (such as TheDescription in @tag {typeExpr} TheDescription ). mustNotHaveValue (boolean) : Set to true if the tag must not have a value. onTagged (function) : A callback function executed when the tag is found. The function is passed two parameters: the doclet and the tag object. lookUp(tagName) : Retrieve a tag object by name. Returns the tag object, including its options, or false if the tag is not defined. isNamespace(tagName) : Returns true if the tag is applied to a doclet's longname as a namespace. normalise(tagName) : Returns the canonical name of a tag. For example, the @const tag is a synonym for @constant ; as a result, if you call normalise('const') , it returns the string constant . normalize(tagName) : Synonym for normalise . Available in JSDoc 3.3.0 and later. A tag's onTagged callback can modify the contents of the doclet or tag. {% example \"Defining an onTagged callback\" %} dictionary.defineTag('instance', { onTagged: function(doclet, tag) { doclet.scope = \"instance\"; } }); {% endexample %} The defineTag method returns a Tag object, which has a synonym method that can be used to declare a synonym for the tag. {% example \"Defining a tag synonym\" %} dictionary.defineTag('exception', { /* options for exception tag */ }) .synonym('throws'); {% endexample %}","title":"The Dictionary"},{"location":"about/plugins/#node-visitors","text":"At the lowest level, plugin authors can process each node in the abstract syntax tree (AST) by defining a node visitor that will visit each node. By using a node-visitor plugin, you can modify comments and trigger parser events for any arbitrary piece of code. Plugins can define a node visitor by exporting an astNodeVisitor object that contains a visitNode function, like so: {% example \"Example\" %} exports.astNodeVisitor = { visitNode: function(node, e, parser, currentSourceName) { // do all sorts of crazy things here } }; {% endexample %} The function is called on each node with the following parameters: node : The AST node. AST nodes are JavaScript objects that use the format defined by the ESTree spec . You can use AST Explorer to see the AST that will be created for your source code. As of version 3.5.0, JSDoc uses the current version of the Babylon parser with all plugins enabled. e : The event. If the node is one that the parser handles, the event object will already be populated with the same things described in the symbolFound event above. Otherwise, it will be an empty object on which to set various properties. parser : The JSDoc parser instance. currentSourceName : The name of the file being parsed.","title":"Node Visitors"},{"location":"about/plugins/#making-things-happen","text":"The primary reasons to implement a node visitor are to be able to document things that aren't normally documented (like function calls that create classes) or to auto generate documentation for code that isn't documented. For instance, a plugin might look for calls to a _trigger method since it knows that means an event is fired and then generate documentation for the event. To make things happen, the visitNode function should modify properties of the event parameter. In general the goal is to construct a comment and then get an event to fire. After the parser lets all of the node visitors have a look at the node, it looks to see if the event object has a comment property and an event property. If it has both, the event named in the event property is fired. The event is usually symbolFound or jsdocCommentFound , but theoretically, a plugin could define its own events and handle them. As with event-handler plugins, a node-visitor plugin can stop later plugins from running by setting a stopPropagation property on the event object ( e.stopPropagation = true ). A plugin can stop the event from firing by setting a preventDefault property ( e.preventDefault = true ).","title":"Making things happen"},{"location":"about/plugins/#reporting-errors","text":"If your plugin needs to report an error, use one of the following methods in the jsdoc/util/logger module: logger.warn : Warn the user about a possible problem. logger.error : Report an error from which the plugin can recover. logger.fatal : Report an error that should cause JSDoc to stop running. Using these methods creates a better user experience than simply throwing an error. Note : Do not use the jsdoc/util/error module to report errors. This module is deprecated and will be removed in a future version of JSDoc. {% example \"Reporting a non-fatal error\" %} var logger = require('jsdoc/util/logger'); exports.handlers = { newDoclet: function(e) { // Your code here. if (somethingBadHappened) { logger.error('Oh, no, something bad happened!'); } } }; {% endexample %}","title":"Reporting Errors"},{"location":"about/tutorials/","text":"JSDoc allows you to include tutorials alongside your API documentation. You can use this feature to provide detailed instructions for using your API, such as a \"getting started\" guide or a step-by-step process for implementing a feature. Adding tutorials To add tutorials to your API documentation, run JSDoc with the --tutorials or -u option, and provide a directory that JSDoc should search for tutorials. For example: jsdoc -u path/to/tutorials path/to/js/files JSDoc searches the tutorials directory for files with the following extensions: .htm .html .markdown (converted from Markdown to HTML) .md (converted from Markdown to HTML) .xhtml .xml (treated as HTML) JSDoc also searches for JSON files that contain information about the titles, ordering, and hierarchy of your tutorials, as discussed in the following section. JSDoc assigns an identifier to each tutorial. The identifier is the filename without its extension. For example, the identifier for /path/to/tutorials/overview.md is overview . In tutorial files, you can use the {@link} and {@tutorial} inline tags to link to other parts of the documentation. JSDoc will automatically resolve the links. Configuring titles, order, and hierarchy By default, JSDoc uses the filename as the tutorial's title, and all tutorials are at the same level. You can use a JSON file to provide a title for each tutorial and indicates how the tutorials should be sorted and grouped in the documentation. The JSON file must use the extension .json . In the JSON file, you can use the tutorial identifiers to provide two properties for each tutorial: title : The title to display in the documentation. children : The children of the tutorial. In JSDoc 3.2.0 and later, you can use the following formats for the JSON file: A tree of objects, with child tutorials defined in the children property of their parent. For example, if tutorial1 has two children, childA and childB , and tutorial2 is at the same level as tutorial1 and has no children: json { \"tutorial1\": { \"title\": \"Tutorial One\", \"children\": { \"childA\": { \"title\": \"Child A\" }, \"childB\": { \"title\": \"Child B\" } } }, \"tutorial2\": { \"title\": \"Tutorial Two\" } } A top-level object whose properties are all tutorial objects, with child tutorials listed by name in an array. For example, if tutorial1 has two children, childA and childB , and tutorial2 is at the same level as tutorial1 and has no children: json { \"tutorial1\": { \"title\": \"Tutorial One\", \"children\": [\"childA\", \"childB\"] }, \"tutorial2\": { \"title\": \"Tutorial Two\" }, \"childA\": { \"title\": \"Child A\" }, \"childB\": { \"title\": \"Child B\" } } You can also provide an individual .json file for each tutorial, using the tutorial identifier as the filename. This method is deprecated and should not be used for new projects. Linking to tutorials from API documentation There are multiple ways to link to a tutorial from your API documentation: @tutorial block tag If you include a @tutorial block tag in a JSDoc comment, the generated documentation will include a link to the tutorial you specify. {% example \"Using the @tutorial block tag\" %} /** * Class representing a socket connection. * * @class * @tutorial socket-tutorial */ function Socket() {} {% endexample %} {@tutorial} inline tag You can also use the {@tutorial} inline tag to link to a tutorial within the text of another tag. By default, JSDoc will use the tutorial's title as the link text. {% example \"Using the {@tutorial} inline tag\" %} /** * Class representing a socket connection. See {@tutorial socket-tutorial} * for an overview. * * @class */ function Socket() {} {% endexample %}","title":"Tutorials"},{"location":"about/tutorials/#adding-tutorials","text":"To add tutorials to your API documentation, run JSDoc with the --tutorials or -u option, and provide a directory that JSDoc should search for tutorials. For example: jsdoc -u path/to/tutorials path/to/js/files JSDoc searches the tutorials directory for files with the following extensions: .htm .html .markdown (converted from Markdown to HTML) .md (converted from Markdown to HTML) .xhtml .xml (treated as HTML) JSDoc also searches for JSON files that contain information about the titles, ordering, and hierarchy of your tutorials, as discussed in the following section. JSDoc assigns an identifier to each tutorial. The identifier is the filename without its extension. For example, the identifier for /path/to/tutorials/overview.md is overview . In tutorial files, you can use the {@link} and {@tutorial} inline tags to link to other parts of the documentation. JSDoc will automatically resolve the links.","title":"Adding tutorials"},{"location":"about/tutorials/#configuring-titles-order-and-hierarchy","text":"By default, JSDoc uses the filename as the tutorial's title, and all tutorials are at the same level. You can use a JSON file to provide a title for each tutorial and indicates how the tutorials should be sorted and grouped in the documentation. The JSON file must use the extension .json . In the JSON file, you can use the tutorial identifiers to provide two properties for each tutorial: title : The title to display in the documentation. children : The children of the tutorial. In JSDoc 3.2.0 and later, you can use the following formats for the JSON file: A tree of objects, with child tutorials defined in the children property of their parent. For example, if tutorial1 has two children, childA and childB , and tutorial2 is at the same level as tutorial1 and has no children: json { \"tutorial1\": { \"title\": \"Tutorial One\", \"children\": { \"childA\": { \"title\": \"Child A\" }, \"childB\": { \"title\": \"Child B\" } } }, \"tutorial2\": { \"title\": \"Tutorial Two\" } } A top-level object whose properties are all tutorial objects, with child tutorials listed by name in an array. For example, if tutorial1 has two children, childA and childB , and tutorial2 is at the same level as tutorial1 and has no children: json { \"tutorial1\": { \"title\": \"Tutorial One\", \"children\": [\"childA\", \"childB\"] }, \"tutorial2\": { \"title\": \"Tutorial Two\" }, \"childA\": { \"title\": \"Child A\" }, \"childB\": { \"title\": \"Child B\" } } You can also provide an individual .json file for each tutorial, using the tutorial identifier as the filename. This method is deprecated and should not be used for new projects.","title":"Configuring titles, order, and hierarchy"},{"location":"about/tutorials/#linking-to-tutorials-from-api-documentation","text":"There are multiple ways to link to a tutorial from your API documentation:","title":"Linking to tutorials from API documentation"},{"location":"about/tutorials/#tutorial-block-tag","text":"If you include a @tutorial block tag in a JSDoc comment, the generated documentation will include a link to the tutorial you specify. {% example \"Using the @tutorial block tag\" %} /** * Class representing a socket connection. * * @class * @tutorial socket-tutorial */ function Socket() {} {% endexample %}","title":"@tutorial block tag"},{"location":"about/tutorials/#tutorial-inline-tag","text":"You can also use the {@tutorial} inline tag to link to a tutorial within the text of another tag. By default, JSDoc will use the tutorial's title as the link text. {% example \"Using the {@tutorial} inline tag\" %} /** * Class representing a socket connection. See {@tutorial socket-tutorial} * for an overview. * * @class */ function Socket() {} {% endexample %}","title":"{@tutorial} inline tag"},{"location":"howto/amd-modules/","text":"Overview JSDoc 3 makes it possible to document modules that use the Asynchronous Module Definition (AMD) API , which is implemented by libraries such as RequireJS . This page explains how to document an AMD module for JSDoc, based on the coding conventions that your module uses. If you're documenting CommonJS or Node.js modules, see CommonJS Modules for instructions. Module identifiers When you document an AMD module, you'll use an @exports tag or @module tag to document the identifier that's passed to the require() function. For example, if users load the module by calling require('my/shirt', /* callback */) , you'll write a JSDoc comment that contains the tag @exports my/shirt or @module my/shirt . The examples below can help you decide which of these tags to use. If you use the @exports or @module tag without a value, JSDoc will try to guess the correct module identifier based on the filepath. When you use a JSDoc namepath to refer to a module from another JSDoc comment, you must add the prefix module: . For example, if you want the documentation for the module my/pants to link to the module my/shirt , you could use the @see tag to document my/pants as follows: /** * Pants module. * @module my/pants * @see module:my/shirt */ Similarly, the namepath for each member of the module will start with module: , followed by the module name. For example, if your my/pants module exports a Jeans constructor, and Jeans has an instance method named hem , the instance method's longname is module:my/pants.Jeans#hem . Function that returns an object literal If you define your AMD module as a function that returns an object literal, use the @exports tag to document the module's name. JSDoc will automatically detect that the object's properties are members of the module. {% example \"Function that returns an object literal\" %} define('my/shirt', function() { /** * A module representing a shirt. * @exports my/shirt */ var shirt = { /** The module's `color` property. */ color: 'black', /** * Create a new Turtleneck. * @class * @param {string} size - The size (`XS`, `S`, `M`, `L`, `XL`, or `XXL`). */ Turtleneck: function(size) { /** The class's `size` property. */ this.size = size; } }; return shirt; }); {% endexample %} Function that returns another function If you define your module as a function that exports another function, such as a constructor, you can use a standalone comment with a @module tag to document the module. You can then use an @alias tag to tell JSDoc that the function uses the same longname as the module. {% example \"Function that returns a constructor\" %} /** * A module representing a jacket. * @module my/jacket */ define('my/jacket', function() { /** * Create a new jacket. * @class * @alias module:my/jacket */ var Jacket = function() { // ... }; /** Zip up the jacket. */ Jacket.prototype.zip = function() { // ... }; return Jacket; }); {% endexample %} Module declared in a return statement If you declare your module object in a function's return statement, you can use a standalone comment with a @module tag to document the module. You can then add an @alias tag to tell JSDoc that the module object has the same longname as the module. {% example \"Module declared in a return statement\" %} /** * Module representing a shirt. * @module my/shirt */ define('my/shirt', function() { // Do setup work here. return /** @alias module:my/shirt */ { /** Color. */ color: 'black', /** Size. */ size: 'unisize' }; }); {% endexample %} Module object passed to a function If the module object is passed into the function that defines your module, you can document the module by adding an @exports tag to the function parameter. This pattern is supported in JSDoc 3.3.0 and later. {% example \"Module object passed to a function\" %} define('my/jacket', function( /** * Utility functions for jackets. * @exports my/jacket */ module) { /** * Zip up a jacket. * @param {Jacket} jacket - The jacket to zip up. */ module.zip = function(jacket) { // ... }; }); {% endexample %} Multiple modules defined in one file If you define more than one AMD module in a single JavaScript file, use the @exports tag to document each module object. {% example \"Multiple AMD modules defined in one file\" %} // one module define('html/utils', function() { /** * Utility functions to ease working with DOM elements. * @exports html/utils */ var utils = { /** * Get the value of a property on an element. * @param {HTMLElement} element - The element. * @param {string} propertyName - The name of the property. * @return {*} The value of the property. */ getStyleProperty: function(element, propertyName) { } }; /** * Determine if an element is in the document head. * @param {HTMLElement} element - The element. * @return {boolean} Set to `true` if the element is in the document head, * `false` otherwise. */ utils.isInHead = function(element) { } return utils; } ); // another module define('tag', function() { /** @exports tag */ var tag = { /** * Create a new Tag. * @class * @param {string} tagName - The name of the tag. */ Tag: function(tagName) { // ... } }; return tag; }); {% endexample %}","title":"AMD Modules"},{"location":"howto/amd-modules/#overview","text":"JSDoc 3 makes it possible to document modules that use the Asynchronous Module Definition (AMD) API , which is implemented by libraries such as RequireJS . This page explains how to document an AMD module for JSDoc, based on the coding conventions that your module uses. If you're documenting CommonJS or Node.js modules, see CommonJS Modules for instructions.","title":"Overview"},{"location":"howto/amd-modules/#module-identifiers","text":"When you document an AMD module, you'll use an @exports tag or @module tag to document the identifier that's passed to the require() function. For example, if users load the module by calling require('my/shirt', /* callback */) , you'll write a JSDoc comment that contains the tag @exports my/shirt or @module my/shirt . The examples below can help you decide which of these tags to use. If you use the @exports or @module tag without a value, JSDoc will try to guess the correct module identifier based on the filepath. When you use a JSDoc namepath to refer to a module from another JSDoc comment, you must add the prefix module: . For example, if you want the documentation for the module my/pants to link to the module my/shirt , you could use the @see tag to document my/pants as follows: /** * Pants module. * @module my/pants * @see module:my/shirt */ Similarly, the namepath for each member of the module will start with module: , followed by the module name. For example, if your my/pants module exports a Jeans constructor, and Jeans has an instance method named hem , the instance method's longname is module:my/pants.Jeans#hem .","title":"Module identifiers"},{"location":"howto/amd-modules/#function-that-returns-an-object-literal","text":"If you define your AMD module as a function that returns an object literal, use the @exports tag to document the module's name. JSDoc will automatically detect that the object's properties are members of the module. {% example \"Function that returns an object literal\" %} define('my/shirt', function() { /** * A module representing a shirt. * @exports my/shirt */ var shirt = { /** The module's `color` property. */ color: 'black', /** * Create a new Turtleneck. * @class * @param {string} size - The size (`XS`, `S`, `M`, `L`, `XL`, or `XXL`). */ Turtleneck: function(size) { /** The class's `size` property. */ this.size = size; } }; return shirt; }); {% endexample %}","title":"Function that returns an object literal"},{"location":"howto/amd-modules/#function-that-returns-another-function","text":"If you define your module as a function that exports another function, such as a constructor, you can use a standalone comment with a @module tag to document the module. You can then use an @alias tag to tell JSDoc that the function uses the same longname as the module. {% example \"Function that returns a constructor\" %} /** * A module representing a jacket. * @module my/jacket */ define('my/jacket', function() { /** * Create a new jacket. * @class * @alias module:my/jacket */ var Jacket = function() { // ... }; /** Zip up the jacket. */ Jacket.prototype.zip = function() { // ... }; return Jacket; }); {% endexample %}","title":"Function that returns another function"},{"location":"howto/amd-modules/#module-declared-in-a-return-statement","text":"If you declare your module object in a function's return statement, you can use a standalone comment with a @module tag to document the module. You can then add an @alias tag to tell JSDoc that the module object has the same longname as the module. {% example \"Module declared in a return statement\" %} /** * Module representing a shirt. * @module my/shirt */ define('my/shirt', function() { // Do setup work here. return /** @alias module:my/shirt */ { /** Color. */ color: 'black', /** Size. */ size: 'unisize' }; }); {% endexample %}","title":"Module declared in a return statement"},{"location":"howto/amd-modules/#module-object-passed-to-a-function","text":"If the module object is passed into the function that defines your module, you can document the module by adding an @exports tag to the function parameter. This pattern is supported in JSDoc 3.3.0 and later. {% example \"Module object passed to a function\" %} define('my/jacket', function( /** * Utility functions for jackets. * @exports my/jacket */ module) { /** * Zip up a jacket. * @param {Jacket} jacket - The jacket to zip up. */ module.zip = function(jacket) { // ... }; }); {% endexample %}","title":"Module object passed to a function"},{"location":"howto/amd-modules/#multiple-modules-defined-in-one-file","text":"If you define more than one AMD module in a single JavaScript file, use the @exports tag to document each module object. {% example \"Multiple AMD modules defined in one file\" %} // one module define('html/utils', function() { /** * Utility functions to ease working with DOM elements. * @exports html/utils */ var utils = { /** * Get the value of a property on an element. * @param {HTMLElement} element - The element. * @param {string} propertyName - The name of the property. * @return {*} The value of the property. */ getStyleProperty: function(element, propertyName) { } }; /** * Determine if an element is in the document head. * @param {HTMLElement} element - The element. * @return {boolean} Set to `true` if the element is in the document head, * `false` otherwise. */ utils.isInHead = function(element) { } return utils; } ); // another module define('tag', function() { /** @exports tag */ var tag = { /** * Create a new Tag. * @class * @param {string} tagName - The name of the tag. */ Tag: function(tagName) { // ... } }; return tag; }); {% endexample %}","title":"Multiple modules defined in one file"},{"location":"howto/commonjs-modules/","text":"Overview To help you document CommonJS modules , JSDoc 3 understands many of the conventions used in the CommonJS specification (for example, adding properties to the exports object). In addition, JSDoc recognizes the conventions of Node.js modules , which extend the CommonJS standard (for example, assigning a value to module.exports ). Depending on the coding conventions you follow, you may need to provide some additional tags to help JSDoc understand your code. This page explains how to document CommonJS and Node.js modules that use several different coding conventions. If you're documenting Asynchronous Module Definition (AMD) modules (also known as \"RequireJS modules\"), see AMD Modules . Module identifiers In most cases, your CommonJS or Node.js module should include a standalone JSDoc comment that contains a @module tag . The @module tag's value should be the module identifier that's passed to the require() function. For example, if users load the module by calling require('my/shirt') , your JSDoc comment would contain the tag @module my/shirt . If you use the @module tag without a value, JSDoc will try to guess the correct module identifier based on the filepath. When you use a JSDoc namepath to refer to a module from another JSDoc comment, you must add the prefix module: . For example, if you want the documentation for the module my/pants to link to the module my/shirt , you could use the @see tag to document my/pants as follows: /** * Pants module. * @module my/pants * @see module:my/shirt */ Similarly, the namepath for each member of the module will start with module: , followed by the module name. For example, if your my/pants module exports a Jeans constructor, and Jeans has an instance method named hem , the instance method's longname is module:my/pants.Jeans#hem . Properties of the 'exports' object It's easiest to document symbols that are directly assigned to a property of the exports object. JSDoc will automatically recognize that the module exports these symbols. In the following example, the my/shirt module exports the methods button and unbutton . JSDoc will automatically detect that the module exports these methods. {% example \"Methods added to the exports object\" %} /** * Shirt module. * @module my/shirt */ /** Button the shirt. */ exports.button = function() { // ... }; /** Unbutton the shirt. */ exports.unbutton = function() { // ... }; {% endexample %} Values assigned to local variables In some cases, an exported symbol may be assigned to a local variable before it's added to the exports object. For example, if your module exports a wash method, and the module itself often calls the wash method, you might write the module as follows: {% example \"Method assigned to a local variable and added to the exports object\" %} /** * Shirt module. * @module my/shirt */ /** Wash the shirt. */ var wash = exports.wash = function() { // ... }; {% endexample %} In this case, JSDoc will not automatically document wash as an exported method, because the JSDoc comment appears immediately before the local variable wash rather than exports.wash . One solution is to add an @alias tag that defines the correct longname for the method. In this case, the method is a static member of the module my/shirt , so the correct longname is module:my/shirt.wash : {% example \"Longname defined in an @alias tag\" %} /** * Shirt module. * @module my/shirt */ /** * Wash the shirt. * @alias module:my/shirt.wash */ var wash = exports.wash = function() { // ... }; {% endexample %} Another solution is to move the method's JSDoc comment so it comes immediately before exports.wash . This change allows JSDoc to detect that wash is exported by the module my/shirt : {% example \"JSDoc comment immediately before exports.wash\" %} /** * Shirt module. * @module my/shirt */ var wash = /** Wash the shirt. */ exports.wash = function() { // ... }; {% endexample %} Values assigned to 'module.exports' In a Node.js module, you can assign a value directly to module.exports . This section explains how to document different types of values when they are assigned to module.exports . Object literal assigned to 'module.exports' If a module assigns an object literal to module.exports . JSDoc automatically recognizes that the module exports only this value. In addition, JSDoc automatically sets the correct longname for each property: {% example \"Object literal assigned to module.exports\" %} /** * Color mixer. * @module color/mixer */ module.exports = { /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ blend: function(color1, color2) { // ... }, /** * Darken a color by the given percentage. * @param {string} color - The color, in hexadecimal format. * @param {number} percent - The percentage, ranging from 0 to 100. * @return {string} The darkened color. */ darken: function(color, percent) { // .. } }; {% endexample %} You can also use this pattern if you add properties to module.exports outside of the object literal: {% example \"Assignment to module.exports followed by property definition\" %} /** * Color mixer. * @module color/mixer */ module.exports = { /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ blend: function(color1, color2) { // ... } }; /** * Darken a color by the given percentage. * @param {string} color - The color, in hexadecimal format. * @param {number} percent - The percentage, ranging from 0 to 100. * @return {string} The darkened color. */ module.exports.darken = function(color, percent) { // .. }; {% endexample %} Function assigned to 'module.exports' If you assign a function to module.exports , JSDoc will automatically set the correct longname for the function: {% example \"Function assigned to 'module.exports'\" %} /** * Color mixer. * @module color/mixer */ /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ module.exports = function(color1, color2) { // ... }; {% endexample %} The same pattern works for constructor functions: {% example \"Constructor assigned to 'module.exports'\" %} /** * Color mixer. * @module color/mixer */ /** Create a color mixer. */ module.exports = function ColorMixer() { // ... }; {% endexample %} String, number, or boolean assigned to 'module.exports' For value types (strings, numbers, and booleans) assigned to module.exports , you must document the exported value's type by using the @type tag in the same JSDoc comment as the @module tag: {% example \"String assigned to module.exports\" %} /** * Module representing the word of the day. * @module wotd * @type {string} */ module.exports = 'perniciousness'; {% endexample %} Values assigned to 'module.exports' and local variables If your module exports symbols that are not directly assigned to module.exports , you can use the @exports tag in place of the @module tag. The @exports tag tells JSDoc that a symbol represents the value exported by a module. {% example \"Object literal assigned to a local variable and module.exports\" %} /** * Color mixer. * @exports color/mixer */ var mixer = module.exports = { /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ blend: function(color1, color2) { // ... } }; {% endexample %} Properties added to 'this' When a module adds a property to its this object, JSDoc 3 automatically recognizes that the new property is exported by the module: {% example \"Properties added to a module's 'this' object\" %} /** * Module for bookshelf-related utilities. * @module bookshelf */ /** * Create a new Book. * @class * @param {string} title - The title of the book. */ this.Book = function(title) { /** The title of the book. */ this.title = title; } {% endexample %}","title":"CommonJS Modules"},{"location":"howto/commonjs-modules/#overview","text":"To help you document CommonJS modules , JSDoc 3 understands many of the conventions used in the CommonJS specification (for example, adding properties to the exports object). In addition, JSDoc recognizes the conventions of Node.js modules , which extend the CommonJS standard (for example, assigning a value to module.exports ). Depending on the coding conventions you follow, you may need to provide some additional tags to help JSDoc understand your code. This page explains how to document CommonJS and Node.js modules that use several different coding conventions. If you're documenting Asynchronous Module Definition (AMD) modules (also known as \"RequireJS modules\"), see AMD Modules .","title":"Overview"},{"location":"howto/commonjs-modules/#module-identifiers","text":"In most cases, your CommonJS or Node.js module should include a standalone JSDoc comment that contains a @module tag . The @module tag's value should be the module identifier that's passed to the require() function. For example, if users load the module by calling require('my/shirt') , your JSDoc comment would contain the tag @module my/shirt . If you use the @module tag without a value, JSDoc will try to guess the correct module identifier based on the filepath. When you use a JSDoc namepath to refer to a module from another JSDoc comment, you must add the prefix module: . For example, if you want the documentation for the module my/pants to link to the module my/shirt , you could use the @see tag to document my/pants as follows: /** * Pants module. * @module my/pants * @see module:my/shirt */ Similarly, the namepath for each member of the module will start with module: , followed by the module name. For example, if your my/pants module exports a Jeans constructor, and Jeans has an instance method named hem , the instance method's longname is module:my/pants.Jeans#hem .","title":"Module identifiers"},{"location":"howto/commonjs-modules/#properties-of-the-exports-object","text":"It's easiest to document symbols that are directly assigned to a property of the exports object. JSDoc will automatically recognize that the module exports these symbols. In the following example, the my/shirt module exports the methods button and unbutton . JSDoc will automatically detect that the module exports these methods. {% example \"Methods added to the exports object\" %} /** * Shirt module. * @module my/shirt */ /** Button the shirt. */ exports.button = function() { // ... }; /** Unbutton the shirt. */ exports.unbutton = function() { // ... }; {% endexample %}","title":"Properties of the 'exports' object"},{"location":"howto/commonjs-modules/#values-assigned-to-local-variables","text":"In some cases, an exported symbol may be assigned to a local variable before it's added to the exports object. For example, if your module exports a wash method, and the module itself often calls the wash method, you might write the module as follows: {% example \"Method assigned to a local variable and added to the exports object\" %} /** * Shirt module. * @module my/shirt */ /** Wash the shirt. */ var wash = exports.wash = function() { // ... }; {% endexample %} In this case, JSDoc will not automatically document wash as an exported method, because the JSDoc comment appears immediately before the local variable wash rather than exports.wash . One solution is to add an @alias tag that defines the correct longname for the method. In this case, the method is a static member of the module my/shirt , so the correct longname is module:my/shirt.wash : {% example \"Longname defined in an @alias tag\" %} /** * Shirt module. * @module my/shirt */ /** * Wash the shirt. * @alias module:my/shirt.wash */ var wash = exports.wash = function() { // ... }; {% endexample %} Another solution is to move the method's JSDoc comment so it comes immediately before exports.wash . This change allows JSDoc to detect that wash is exported by the module my/shirt : {% example \"JSDoc comment immediately before exports.wash\" %} /** * Shirt module. * @module my/shirt */ var wash = /** Wash the shirt. */ exports.wash = function() { // ... }; {% endexample %}","title":"Values assigned to local variables"},{"location":"howto/commonjs-modules/#values-assigned-to-moduleexports","text":"In a Node.js module, you can assign a value directly to module.exports . This section explains how to document different types of values when they are assigned to module.exports .","title":"Values assigned to 'module.exports'"},{"location":"howto/commonjs-modules/#object-literal-assigned-to-moduleexports","text":"If a module assigns an object literal to module.exports . JSDoc automatically recognizes that the module exports only this value. In addition, JSDoc automatically sets the correct longname for each property: {% example \"Object literal assigned to module.exports\" %} /** * Color mixer. * @module color/mixer */ module.exports = { /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ blend: function(color1, color2) { // ... }, /** * Darken a color by the given percentage. * @param {string} color - The color, in hexadecimal format. * @param {number} percent - The percentage, ranging from 0 to 100. * @return {string} The darkened color. */ darken: function(color, percent) { // .. } }; {% endexample %} You can also use this pattern if you add properties to module.exports outside of the object literal: {% example \"Assignment to module.exports followed by property definition\" %} /** * Color mixer. * @module color/mixer */ module.exports = { /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ blend: function(color1, color2) { // ... } }; /** * Darken a color by the given percentage. * @param {string} color - The color, in hexadecimal format. * @param {number} percent - The percentage, ranging from 0 to 100. * @return {string} The darkened color. */ module.exports.darken = function(color, percent) { // .. }; {% endexample %}","title":"Object literal assigned to 'module.exports'"},{"location":"howto/commonjs-modules/#function-assigned-to-moduleexports","text":"If you assign a function to module.exports , JSDoc will automatically set the correct longname for the function: {% example \"Function assigned to 'module.exports'\" %} /** * Color mixer. * @module color/mixer */ /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ module.exports = function(color1, color2) { // ... }; {% endexample %} The same pattern works for constructor functions: {% example \"Constructor assigned to 'module.exports'\" %} /** * Color mixer. * @module color/mixer */ /** Create a color mixer. */ module.exports = function ColorMixer() { // ... }; {% endexample %}","title":"Function assigned to 'module.exports'"},{"location":"howto/commonjs-modules/#string-number-or-boolean-assigned-to-moduleexports","text":"For value types (strings, numbers, and booleans) assigned to module.exports , you must document the exported value's type by using the @type tag in the same JSDoc comment as the @module tag: {% example \"String assigned to module.exports\" %} /** * Module representing the word of the day. * @module wotd * @type {string} */ module.exports = 'perniciousness'; {% endexample %}","title":"String, number, or boolean assigned to 'module.exports'"},{"location":"howto/commonjs-modules/#values-assigned-to-moduleexports-and-local-variables","text":"If your module exports symbols that are not directly assigned to module.exports , you can use the @exports tag in place of the @module tag. The @exports tag tells JSDoc that a symbol represents the value exported by a module. {% example \"Object literal assigned to a local variable and module.exports\" %} /** * Color mixer. * @exports color/mixer */ var mixer = module.exports = { /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ blend: function(color1, color2) { // ... } }; {% endexample %}","title":"Values assigned to 'module.exports' and local variables"},{"location":"howto/commonjs-modules/#properties-added-to-this","text":"When a module adds a property to its this object, JSDoc 3 automatically recognizes that the new property is exported by the module: {% example \"Properties added to a module's 'this' object\" %} /** * Module for bookshelf-related utilities. * @module bookshelf */ /** * Create a new Book. * @class * @param {string} title - The title of the book. */ this.Book = function(title) { /** The title of the book. */ this.title = title; } {% endexample %}","title":"Properties added to 'this'"},{"location":"howto/es2015-classes/","text":"JSDoc 3 makes it easy to document classes that follow the ECMAScript 2015 specification . You don't need to use tags such as @class and @constructor with ES 2015 classes\u2014JSDoc automatically identifies classes and their constructors simply by parsing your code. ES 2015 classes are supported in JSDoc 3.4.0 and later. Documenting a simple class The following example shows how to document a simple class with a constructor, two instance methods, and one static method: {% example \"Simple ES 2015 class\" %} /** Class representing a point. */ class Point { /** * Create a point. * @param {number} x - The x value. * @param {number} y - The y value. */ constructor(x, y) { // ... } /** * Get the x value. * @return {number} The x value. */ getX() { // ... } /** * Get the y value. * @return {number} The y value. */ getY() { // ... } /** * Convert a string containing two comma-separated numbers into a point. * @param {string} str - The string containing two comma-separated numbers. * @return {Point} A Point object. */ static fromString(str) { // ... } } {% endexample %} You can also document classes that are defined in a class expression, which assigns the class to a variable or constant: {% example \"ES 2015 class expression\" %} /** Class representing a point. */ const Point = class { // and so on } {% endexample %} Extending classes When you use the extends keyword to extend an existing class, you also need to tell JSDoc which class you're extending. You do this with the @augments (or @extends ) tag . For example, to extend the Point class shown above: {% example \"Extending an ES 2015 class\" %} /** * Class representing a dot. * @extends Point */ class Dot extends Point { /** * Create a dot. * @param {number} x - The x value. * @param {number} y - The y value. * @param {number} width - The width of the dot, in pixels. */ constructor(x, y, width) { // ... } /** * Get the dot's width. * @return {number} The dot's width, in pixels. */ getWidth() { // ... } } {% endexample %}","title":"ES 2015 Classes"},{"location":"howto/es2015-classes/#documenting-a-simple-class","text":"The following example shows how to document a simple class with a constructor, two instance methods, and one static method: {% example \"Simple ES 2015 class\" %} /** Class representing a point. */ class Point { /** * Create a point. * @param {number} x - The x value. * @param {number} y - The y value. */ constructor(x, y) { // ... } /** * Get the x value. * @return {number} The x value. */ getX() { // ... } /** * Get the y value. * @return {number} The y value. */ getY() { // ... } /** * Convert a string containing two comma-separated numbers into a point. * @param {string} str - The string containing two comma-separated numbers. * @return {Point} A Point object. */ static fromString(str) { // ... } } {% endexample %} You can also document classes that are defined in a class expression, which assigns the class to a variable or constant: {% example \"ES 2015 class expression\" %} /** Class representing a point. */ const Point = class { // and so on } {% endexample %}","title":"Documenting a simple class"},{"location":"howto/es2015-classes/#extending-classes","text":"When you use the extends keyword to extend an existing class, you also need to tell JSDoc which class you're extending. You do this with the @augments (or @extends ) tag . For example, to extend the Point class shown above: {% example \"Extending an ES 2015 class\" %} /** * Class representing a dot. * @extends Point */ class Dot extends Point { /** * Create a dot. * @param {number} x - The x value. * @param {number} y - The y value. * @param {number} width - The width of the dot, in pixels. */ constructor(x, y, width) { // ... } /** * Get the dot's width. * @return {number} The dot's width, in pixels. */ getWidth() { // ... } } {% endexample %}","title":"Extending classes"},{"location":"howto/es2015-modules/","text":"JSDoc 3 makes it possible to document modules that follow the ECMAScript 2015 specification . ES 2015 modules are supported in JSDoc 3.4.0 and later. Module identifiers When you document an ES 2015 module, you'll use a @module tag to document the identifier for the module. For example, if users load the module by calling import * as myShirt from 'my/shirt' , you'll write a JSDoc comment that contains the tag @module my/shirt . If you use the @module tag without a value, JSDoc will try to guess the correct module identifier based on the filepath. When you use a JSDoc namepath to refer to a module from another JSDoc comment, you must add the prefix module: . For example, if you want the documentation for the module my/pants to link to the module my/shirt , you could use the @see tag to document my/pants as follows: /** * Pants module. * @module my/pants * @see module:my/shirt */ Similarly, the namepath for each member of the module will start with module: , followed by the module name. For example, if your my/pants module exports a Jeans class, and Jeans has an instance method named hem , the instance method's longname is module:my/pants.Jeans#hem . Exported values The following example shows how to document different kinds of exported values in an ES 2015 module. In most cases, you can simply add a JSDoc comment to the export statement that defines the exported value. If you are exporting a value under another name, you can document the exported value within its export block. {% example \"Documenting values exported by a module\" %} /** @module color/mixer */ /** The name of the module. */ export const name = 'mixer'; /** The most recent blended color. */ export var lastColor = null; /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ export function blend(color1, color2) {} // convert color to array of RGB values (0-255) function rgbify(color) {} export { /** * Get the red, green, and blue values of a color. * @function * @param {string} color - A color, in hexadecimal format. * @returns {Array.&lt;number>} An array of the red, green, and blue values, * each ranging from 0 to 255. */ rgbify as toRgb } {% endexample %}","title":"ES 2015 Modules"},{"location":"howto/es2015-modules/#module-identifiers","text":"When you document an ES 2015 module, you'll use a @module tag to document the identifier for the module. For example, if users load the module by calling import * as myShirt from 'my/shirt' , you'll write a JSDoc comment that contains the tag @module my/shirt . If you use the @module tag without a value, JSDoc will try to guess the correct module identifier based on the filepath. When you use a JSDoc namepath to refer to a module from another JSDoc comment, you must add the prefix module: . For example, if you want the documentation for the module my/pants to link to the module my/shirt , you could use the @see tag to document my/pants as follows: /** * Pants module. * @module my/pants * @see module:my/shirt */ Similarly, the namepath for each member of the module will start with module: , followed by the module name. For example, if your my/pants module exports a Jeans class, and Jeans has an instance method named hem , the instance method's longname is module:my/pants.Jeans#hem .","title":"Module identifiers"},{"location":"howto/es2015-modules/#exported-values","text":"The following example shows how to document different kinds of exported values in an ES 2015 module. In most cases, you can simply add a JSDoc comment to the export statement that defines the exported value. If you are exporting a value under another name, you can document the exported value within its export block. {% example \"Documenting values exported by a module\" %} /** @module color/mixer */ /** The name of the module. */ export const name = 'mixer'; /** The most recent blended color. */ export var lastColor = null; /** * Blend two colors together. * @param {string} color1 - The first color, in hexadecimal format. * @param {string} color2 - The second color, in hexadecimal format. * @return {string} The blended color. */ export function blend(color1, color2) {} // convert color to array of RGB values (0-255) function rgbify(color) {} export { /** * Get the red, green, and blue values of a color. * @function * @param {string} color - A color, in hexadecimal format. * @returns {Array.&lt;number>} An array of the red, green, and blue values, * each ranging from 0 to 255. */ rgbify as toRgb } {% endexample %}","title":"Exported values"},{"location":"tags/abstract/","text":"Overview The @abstract tag identifies members that must be implemented (or overridden) by objects that inherit the member. Example {% example \"Parent class with abstract method, and child class that implements the method\" %} /** * Generic dairy product. * @constructor */ function DairyProduct() {} /** * Check whether the dairy product is solid at room temperature. * @abstract * @return {boolean} */ DairyProduct.prototype.isSolid = function() { throw new Error('must be implemented by subclass!'); }; /** * Cool, refreshing milk. * @constructor * @augments DairyProduct */ function Milk() {} /** * Check whether milk is solid at room temperature. * @return {boolean} Always returns false. */ Milk.prototype.isSolid = function() { return false; }; {% endexample %}","title":"Abstract"},{"location":"tags/abstract/#overview","text":"The @abstract tag identifies members that must be implemented (or overridden) by objects that inherit the member.","title":"Overview"},{"location":"tags/abstract/#example","text":"{% example \"Parent class with abstract method, and child class that implements the method\" %} /** * Generic dairy product. * @constructor */ function DairyProduct() {} /** * Check whether the dairy product is solid at room temperature. * @abstract * @return {boolean} */ DairyProduct.prototype.isSolid = function() { throw new Error('must be implemented by subclass!'); }; /** * Cool, refreshing milk. * @constructor * @augments DairyProduct */ function Milk() {} /** * Check whether milk is solid at room temperature. * @return {boolean} Always returns false. */ Milk.prototype.isSolid = function() { return false; }; {% endexample %}","title":"Example"},{"location":"tags/access/","text":"Syntax @access <package|private|protected|public> Overview The @access tag specifies the access level of a member. You can use the @access tag as a synonym for other tags: @access package is the same as @package . This option is available in JSDoc 3.5.0 and later. @access private is the same as @private . @access protected is the same as @protected . @access public is the same as @public . Private members are not shown in the generated output unless JSDoc is run with the -p/--private command-line option. In JSDoc 3.3.0 and later, you can also use the -a/--access command-line option to change this behavior. Note that a doclet's access level is different from its scope . For example, if Parent has an inner variable named child that is documented as @public , the child variable will still be treated as an inner variable with the namepath Parent~child . In other words, the child variable will have an inner scope, even though the variable is public. To change a doclet's scope, use the @instance , @static , and @global tags. Examples {% example \"Using @access as a synonym for other tags\" %} /** @constructor */ function Thingy() { /** @access private */ var foo = 0; /** @access protected */ this._bar = 1; /** @access package */ this.baz = 2; /** @access public */ this.pez = 3; } // same as... /** @constructor */ function OtherThingy() { /** @private */ var foo = 0; /** @protected */ this._bar = 1; /** @package */ this.baz = 2; /** @public */ this.pez = 3; } {% endexample %}","title":"Access"},{"location":"tags/access/#syntax","text":"@access <package|private|protected|public>","title":"Syntax"},{"location":"tags/access/#overview","text":"The @access tag specifies the access level of a member. You can use the @access tag as a synonym for other tags: @access package is the same as @package . This option is available in JSDoc 3.5.0 and later. @access private is the same as @private . @access protected is the same as @protected . @access public is the same as @public . Private members are not shown in the generated output unless JSDoc is run with the -p/--private command-line option. In JSDoc 3.3.0 and later, you can also use the -a/--access command-line option to change this behavior. Note that a doclet's access level is different from its scope . For example, if Parent has an inner variable named child that is documented as @public , the child variable will still be treated as an inner variable with the namepath Parent~child . In other words, the child variable will have an inner scope, even though the variable is public. To change a doclet's scope, use the @instance , @static , and @global tags.","title":"Overview"},{"location":"tags/access/#examples","text":"{% example \"Using @access as a synonym for other tags\" %} /** @constructor */ function Thingy() { /** @access private */ var foo = 0; /** @access protected */ this._bar = 1; /** @access package */ this.baz = 2; /** @access public */ this.pez = 3; } // same as... /** @constructor */ function OtherThingy() { /** @private */ var foo = 0; /** @protected */ this._bar = 1; /** @package */ this.baz = 2; /** @public */ this.pez = 3; } {% endexample %}","title":"Examples"},{"location":"tags/alias/","text":"Syntax @alias <aliasNamepath> Overview The @alias tag causes JSDoc to treat all references to a member as if the member had a different name. This tag is especially useful if you define a class within an inner function; in this case, you can use the @alias tag to tell JSDoc how the class is exposed in your app. While the @alias tag may sound similar to the @name tag, these tags behave very differently. The @name tag tells JSDoc to ignore any code associated with the comment. For example, when JSDoc processes the following code, it ignores the fact that the comment for bar is attached to a function: /** * Bar function. * @name bar */ function foo() {} The @alias tag tells JSDoc to pretend that Member A is actually named Member B. For example, when JSDoc processes the following code, it recognizes that foo is a function, then renames foo to bar in the documentation: {% example %} /** * Bar function. * @alias bar */ function foo() {} {% endexample %} Examples Suppose you are using a class framework that expects you to pass in a constructor function when you define a class. You can use the @alias tag to tell JSDoc how the class will be exposed in your app. In the following example, the @alias tag tells JSDoc to treat the anonymous function as if it were the constructor for the class \"trackr.CookieManager\". Within the function, JSDoc interprets the this keyword relative to trackr.CookieManager, so the \"value\" method has the namepath \"trackr.CookieManager#value\". {% example \"Using @alias with an anonymous constructor function\" %} Klass('trackr.CookieManager', /** * @class * @alias trackr.CookieManager * @param {Object} kv */ function(kv) { /** The value. */ this.value = kv; } ); {% endexample %} You can also use the @alias tag with members that are created within an immediately invoked function expression (IIFE). The @alias tag tells JSDoc that these members are exposed outside of the IIFE's scope. {% example \"Using @alias for static members of a namespace\" %} /** @namespace */ var Apple = {}; (function(ns) { /** * @namespace * @alias Apple.Core */ var core = {}; /** Documented as Apple.Core.seed */ core.seed = function() {}; ns.Core = core; })(Apple); {% endexample %} For members that are defined within an object literal, you can use the @alias tag as an alternative to the @lends tag. {% example \"Using @alias for an object literal\" %} // Documenting objectA with @alias var objectA = (function() { /** * Documented as objectA * @alias objectA * @namespace */ var x = { /** * Documented as objectA.myProperty * @member */ myProperty: 'foo' }; return x; })(); // Documenting objectB with @lends /** * Documented as objectB * @namespace */ var objectB = (function() { /** @lends objectB */ var x = { /** * Documented as objectB.myProperty * @member */ myProperty: 'bar' }; return x; })(); {% endexample %}","title":"Alias"},{"location":"tags/alias/#syntax","text":"@alias <aliasNamepath>","title":"Syntax"},{"location":"tags/alias/#overview","text":"The @alias tag causes JSDoc to treat all references to a member as if the member had a different name. This tag is especially useful if you define a class within an inner function; in this case, you can use the @alias tag to tell JSDoc how the class is exposed in your app. While the @alias tag may sound similar to the @name tag, these tags behave very differently. The @name tag tells JSDoc to ignore any code associated with the comment. For example, when JSDoc processes the following code, it ignores the fact that the comment for bar is attached to a function: /** * Bar function. * @name bar */ function foo() {} The @alias tag tells JSDoc to pretend that Member A is actually named Member B. For example, when JSDoc processes the following code, it recognizes that foo is a function, then renames foo to bar in the documentation: {% example %} /** * Bar function. * @alias bar */ function foo() {} {% endexample %}","title":"Overview"},{"location":"tags/alias/#examples","text":"Suppose you are using a class framework that expects you to pass in a constructor function when you define a class. You can use the @alias tag to tell JSDoc how the class will be exposed in your app. In the following example, the @alias tag tells JSDoc to treat the anonymous function as if it were the constructor for the class \"trackr.CookieManager\". Within the function, JSDoc interprets the this keyword relative to trackr.CookieManager, so the \"value\" method has the namepath \"trackr.CookieManager#value\". {% example \"Using @alias with an anonymous constructor function\" %} Klass('trackr.CookieManager', /** * @class * @alias trackr.CookieManager * @param {Object} kv */ function(kv) { /** The value. */ this.value = kv; } ); {% endexample %} You can also use the @alias tag with members that are created within an immediately invoked function expression (IIFE). The @alias tag tells JSDoc that these members are exposed outside of the IIFE's scope. {% example \"Using @alias for static members of a namespace\" %} /** @namespace */ var Apple = {}; (function(ns) { /** * @namespace * @alias Apple.Core */ var core = {}; /** Documented as Apple.Core.seed */ core.seed = function() {}; ns.Core = core; })(Apple); {% endexample %} For members that are defined within an object literal, you can use the @alias tag as an alternative to the @lends tag. {% example \"Using @alias for an object literal\" %} // Documenting objectA with @alias var objectA = (function() { /** * Documented as objectA * @alias objectA * @namespace */ var x = { /** * Documented as objectA.myProperty * @member */ myProperty: 'foo' }; return x; })(); // Documenting objectB with @lends /** * Documented as objectB * @namespace */ var objectB = (function() { /** @lends objectB */ var x = { /** * Documented as objectB.myProperty * @member */ myProperty: 'bar' }; return x; })(); {% endexample %}","title":"Examples"},{"location":"tags/async/","text":"Syntax @async Overview The @async tag indicates that a function is asynchronous , meaning that it was declared using the syntax async function foo() {} . Do not use this tag for other types of asynchronous functions, such as functions that provide a callback. This tag is available in JSDoc 3.5.0 and later. In general, you do not need to use this tag, because JSDoc automatically detects asynchronous functions and identifies them in the generated documentation. However, if you are writing a virtual comment for an asynchronous function that does not appear in your code, you can use this tag to tell JSDoc that the function is asynchronous. Example The following example shows a virtual comment that uses the @async tag: {% example \"Virtual comment with @async tag\" %} /** * Download data from the specified URL. * * @async * @function downloadData * @param {string} url - The URL to download from. * @return {Promise&lt;string>} The data from the URL. */ {% endexample %}","title":"Async"},{"location":"tags/async/#syntax","text":"@async","title":"Syntax"},{"location":"tags/async/#overview","text":"The @async tag indicates that a function is asynchronous , meaning that it was declared using the syntax async function foo() {} . Do not use this tag for other types of asynchronous functions, such as functions that provide a callback. This tag is available in JSDoc 3.5.0 and later. In general, you do not need to use this tag, because JSDoc automatically detects asynchronous functions and identifies them in the generated documentation. However, if you are writing a virtual comment for an asynchronous function that does not appear in your code, you can use this tag to tell JSDoc that the function is asynchronous.","title":"Overview"},{"location":"tags/async/#example","text":"The following example shows a virtual comment that uses the @async tag: {% example \"Virtual comment with @async tag\" %} /** * Download data from the specified URL. * * @async * @function downloadData * @param {string} url - The URL to download from. * @return {Promise&lt;string>} The data from the URL. */ {% endexample %}","title":"Example"},{"location":"tags/augments/","text":"Syntax @augments <namepath> Overview The @augments or @extends tag indicates that a symbol inherits from, and potentially adds to, a parent symbol. You can use this tag to document both class-based and prototype-based inheritance. In JSDoc 3.3.0 and later, if a symbol inherits from multiple parents, and both parents have identically named members, JSDoc uses the documentation from the last parent that is listed in the JSDoc comment. Examples In the following example, the Duck class is defined as a subclass of Animal . Duck instances have the same properties as Animal instances, as well as a speak method that is unique to Duck instances. {% example \"Documenting a class/subclass relationship\" %} /** * @constructor */ function Animal() { /** Is this animal alive? */ this.alive = true; } /** * @constructor * @augments Animal */ function Duck() {} Duck.prototype = new Animal(); /** What do ducks say? */ Duck.prototype.speak = function() { if (this.alive) { alert('Quack!'); } }; var d = new Duck(); d.speak(); // Quack! d.alive = false; d.speak(); // (nothing) {% endexample %} In the following example, the Duck class inherits from both the Flyable and Bird classes, both of which define a takeOff method. Because the documentation for Duck lists @augments Bird last, JSDoc automatically documents Duck#takeOff using the comment from Bird#takeOff . {% example \"Multiple inheritance with duplicated method names\" %} /** * Abstract class for things that can fly. * @class */ function Flyable() { this.canFly = true; } /** Take off. */ Flyable.prototype.takeOff = function() { // ... }; /** * Abstract class representing a bird. * @class */ function Bird(canFly) { this.canFly = canFly; } /** Spread your wings and fly, if possible. */ Bird.prototype.takeOff = function() { if (this.canFly) { this._spreadWings() ._run() ._flapWings(); } }; /** * Class representing a duck. * @class * @augments Flyable * @augments Bird */ function Duck() {} // Described in the docs as \"Spread your wings and fly, if possible.\" Duck.prototype.takeOff = function() { // ... }; {% endexample %}","title":"Augments"},{"location":"tags/augments/#syntax","text":"@augments <namepath>","title":"Syntax"},{"location":"tags/augments/#overview","text":"The @augments or @extends tag indicates that a symbol inherits from, and potentially adds to, a parent symbol. You can use this tag to document both class-based and prototype-based inheritance. In JSDoc 3.3.0 and later, if a symbol inherits from multiple parents, and both parents have identically named members, JSDoc uses the documentation from the last parent that is listed in the JSDoc comment.","title":"Overview"},{"location":"tags/augments/#examples","text":"In the following example, the Duck class is defined as a subclass of Animal . Duck instances have the same properties as Animal instances, as well as a speak method that is unique to Duck instances. {% example \"Documenting a class/subclass relationship\" %} /** * @constructor */ function Animal() { /** Is this animal alive? */ this.alive = true; } /** * @constructor * @augments Animal */ function Duck() {} Duck.prototype = new Animal(); /** What do ducks say? */ Duck.prototype.speak = function() { if (this.alive) { alert('Quack!'); } }; var d = new Duck(); d.speak(); // Quack! d.alive = false; d.speak(); // (nothing) {% endexample %} In the following example, the Duck class inherits from both the Flyable and Bird classes, both of which define a takeOff method. Because the documentation for Duck lists @augments Bird last, JSDoc automatically documents Duck#takeOff using the comment from Bird#takeOff . {% example \"Multiple inheritance with duplicated method names\" %} /** * Abstract class for things that can fly. * @class */ function Flyable() { this.canFly = true; } /** Take off. */ Flyable.prototype.takeOff = function() { // ... }; /** * Abstract class representing a bird. * @class */ function Bird(canFly) { this.canFly = canFly; } /** Spread your wings and fly, if possible. */ Bird.prototype.takeOff = function() { if (this.canFly) { this._spreadWings() ._run() ._flapWings(); } }; /** * Class representing a duck. * @class * @augments Flyable * @augments Bird */ function Duck() {} // Described in the docs as \"Spread your wings and fly, if possible.\" Duck.prototype.takeOff = function() { // ... }; {% endexample %}","title":"Examples"},{"location":"tags/author/","text":"Syntax @author <name> [<emailAddress>] Overview The @author tag identifies the author of an item. In JSDoc 3.2 and later, if the author's name is followed by an email address enclosed in angle brackets, the default template will convert the email address to a mailto: link. Examples {% example \"Documenting the author of an item\" %} /** * @author Jane Smith &lt;jsmith@example.com> */ function MyClass() {} {% endexample %}","title":"Author"},{"location":"tags/author/#syntax","text":"@author <name> [<emailAddress>]","title":"Syntax"},{"location":"tags/author/#overview","text":"The @author tag identifies the author of an item. In JSDoc 3.2 and later, if the author's name is followed by an email address enclosed in angle brackets, the default template will convert the email address to a mailto: link.","title":"Overview"},{"location":"tags/author/#examples","text":"{% example \"Documenting the author of an item\" %} /** * @author Jane Smith &lt;jsmith@example.com> */ function MyClass() {} {% endexample %}","title":"Examples"},{"location":"tags/borrows/","text":"Syntax @borrows <that namepath> as <this namepath> Overview The @borrows tag allows you to add documentation for another symbol to your documentation. This tag would be useful if you had more than one way to reference a function, but you didn't want to duplicate the same documentation in two places. Examples In this example there exists documentation for the \"trstr\" function, but \"util.trim\" is just a reference to that same function by a different name. {% example \"Duplicate the documentation for trstr as util.trim\" %} /** * @namespace * @borrows trstr as trim */ var util = { trim: trstr }; /** * Remove whitespace from around a string. * @param {string} str */ function trstr(str) { } {% endexample %}","title":"Borrows"},{"location":"tags/borrows/#syntax","text":"@borrows <that namepath> as <this namepath>","title":"Syntax"},{"location":"tags/borrows/#overview","text":"The @borrows tag allows you to add documentation for another symbol to your documentation. This tag would be useful if you had more than one way to reference a function, but you didn't want to duplicate the same documentation in two places.","title":"Overview"},{"location":"tags/borrows/#examples","text":"In this example there exists documentation for the \"trstr\" function, but \"util.trim\" is just a reference to that same function by a different name. {% example \"Duplicate the documentation for trstr as util.trim\" %} /** * @namespace * @borrows trstr as trim */ var util = { trim: trstr }; /** * Remove whitespace from around a string. * @param {string} str */ function trstr(str) { } {% endexample %}","title":"Examples"},{"location":"tags/callback/","text":"Syntax @callback <namepath> Overview The @callback tag provides information about a callback function that can be passed to other functions, including the callback's parameters and return value. You can include any of the tags that you can provide for a @method. Once you define a callback, you can use it in the same way as a custom type defined with the @typedef tag. In particular, you can use the callback's name as a type name. This allows you to indicate that a function parameter should contain a certain type of callback. If you want a callback to be displayed with the type definitions for a specific class, you can give the callback a namepath indicating that it is an inner function of that class. You can also define a global callback type that is referenced from multiple classes. Examples {% example \"Documenting a class-specific callback\" %} /** * @class */ function Requester() {} /** * Send a request. * @param {Requester~requestCallback} cb - The callback that handles the response. */ Requester.prototype.send = function(cb) { // code }; /** * This callback is displayed as part of the Requester class. * @callback Requester~requestCallback * @param {number} responseCode * @param {string} responseMessage */ {% endexample %} {% example \"Documenting a global callback\" %} /** * @class */ function Requester() {} /** * Send a request. * @param {requestCallback} cb - The callback that handles the response. */ Requester.prototype.send = function(cb) { // code }; /** * This callback is displayed as a global member. * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage */ {% endexample %}","title":"Callback"},{"location":"tags/callback/#syntax","text":"@callback <namepath>","title":"Syntax"},{"location":"tags/callback/#overview","text":"The @callback tag provides information about a callback function that can be passed to other functions, including the callback's parameters and return value. You can include any of the tags that you can provide for a @method. Once you define a callback, you can use it in the same way as a custom type defined with the @typedef tag. In particular, you can use the callback's name as a type name. This allows you to indicate that a function parameter should contain a certain type of callback. If you want a callback to be displayed with the type definitions for a specific class, you can give the callback a namepath indicating that it is an inner function of that class. You can also define a global callback type that is referenced from multiple classes.","title":"Overview"},{"location":"tags/callback/#examples","text":"{% example \"Documenting a class-specific callback\" %} /** * @class */ function Requester() {} /** * Send a request. * @param {Requester~requestCallback} cb - The callback that handles the response. */ Requester.prototype.send = function(cb) { // code }; /** * This callback is displayed as part of the Requester class. * @callback Requester~requestCallback * @param {number} responseCode * @param {string} responseMessage */ {% endexample %} {% example \"Documenting a global callback\" %} /** * @class */ function Requester() {} /** * Send a request. * @param {requestCallback} cb - The callback that handles the response. */ Requester.prototype.send = function(cb) { // code }; /** * This callback is displayed as a global member. * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage */ {% endexample %}","title":"Examples"},{"location":"tags/class/","text":"Syntax @class [<type> <name>] Overview The @class tag marks a function as being a constructor, meant to be called with the new keyword to return an instance. Examples {% example \"A function that constructs Person instances.\" %} /** * Creates a new Person. * @class */ function Person() { } var p = new Person(); {% endexample %}","title":"Class"},{"location":"tags/class/#syntax","text":"@class [<type> <name>]","title":"Syntax"},{"location":"tags/class/#overview","text":"The @class tag marks a function as being a constructor, meant to be called with the new keyword to return an instance.","title":"Overview"},{"location":"tags/class/#examples","text":"{% example \"A function that constructs Person instances.\" %} /** * Creates a new Person. * @class */ function Person() { } var p = new Person(); {% endexample %}","title":"Examples"},{"location":"tags/classdesc/","text":"Syntax @classdesc <some description> Overview The @classdesc tag is used to provide a description for a class, separate from the constructor function's description. Use the @classdesc tag in combination with the @class (or @constructor) tag . The functionality of the @classdesc tag in JSDoc 3 duplicates that of the @class in previous versions. As of version 3, the syntax and functionality of the @class tag now exactly matches the @constructor tag, and the @classdesc tag more explicitly communicates its purpose: to document a class's description. Examples As shown below, a class has places for two descriptions, one applies to the function itself, while the other applies to the class in general. {% example \"A doclet with both a constructor function description and a class description\" %} /** * This is a description of the MyClass constructor function. * @class * @classdesc This is a description of the MyClass class. */ function MyClass() { } {% endexample %}","title":"Classdesc"},{"location":"tags/classdesc/#syntax","text":"@classdesc <some description>","title":"Syntax"},{"location":"tags/classdesc/#overview","text":"The @classdesc tag is used to provide a description for a class, separate from the constructor function's description. Use the @classdesc tag in combination with the @class (or @constructor) tag . The functionality of the @classdesc tag in JSDoc 3 duplicates that of the @class in previous versions. As of version 3, the syntax and functionality of the @class tag now exactly matches the @constructor tag, and the @classdesc tag more explicitly communicates its purpose: to document a class's description.","title":"Overview"},{"location":"tags/classdesc/#examples","text":"As shown below, a class has places for two descriptions, one applies to the function itself, while the other applies to the class in general. {% example \"A doclet with both a constructor function description and a class description\" %} /** * This is a description of the MyClass constructor function. * @class * @classdesc This is a description of the MyClass class. */ function MyClass() { } {% endexample %}","title":"Examples"},{"location":"tags/constant/","text":"Syntax @constant [<type> <name>] Overview The @constant tag is used to mark the documentation as belonging to a symbol that is a constant. Examples In this example we are documenting a string constant. Note that although the code is using the const keyword, this is not required by JSDoc. If your JavaScript host environment doesn't yet support constant declarations, the @const documentation can just as effectively be used on var declarations. {% example \"A string constant representing the color red\" %} /** @constant @type {string} @default */ const RED = 'FF0000'; /** @constant {number} */ var ONE = 1; {% endexample %} Note that the example provides the type in a @type tag. This is optional. Also the optional @default tag is used here too, this will automatically add whatever the assigned value is (for example 'FF0000') to the documentation.","title":"Constant"},{"location":"tags/constant/#syntax","text":"@constant [<type> <name>]","title":"Syntax"},{"location":"tags/constant/#overview","text":"The @constant tag is used to mark the documentation as belonging to a symbol that is a constant.","title":"Overview"},{"location":"tags/constant/#examples","text":"In this example we are documenting a string constant. Note that although the code is using the const keyword, this is not required by JSDoc. If your JavaScript host environment doesn't yet support constant declarations, the @const documentation can just as effectively be used on var declarations. {% example \"A string constant representing the color red\" %} /** @constant @type {string} @default */ const RED = 'FF0000'; /** @constant {number} */ var ONE = 1; {% endexample %} Note that the example provides the type in a @type tag. This is optional. Also the optional @default tag is used here too, this will automatically add whatever the assigned value is (for example 'FF0000') to the documentation.","title":"Examples"},{"location":"tags/constructs/","text":"Overview When using an object literal to define a class (for example with the @lends tag) the @constructs tag allows you to document that a particular function will be used to construct instances of that class. Syntax @constructs [<name>] Examples {% example \"Using the @constructs tag with @lends\" %} var Person = makeClass( /** @lends Person.prototype */ { /** @constructs */ initialize: function(name) { this.name = name; }, /** Describe me. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} {% example \"Without @lends you must provide the name of the class\" %} makeClass('Menu', /** * @constructs Menu * @param items */ function (items) { }, { /** @memberof Menu# */ show: function(){ } } ); {% endexample %}","title":"Constructs"},{"location":"tags/constructs/#overview","text":"When using an object literal to define a class (for example with the @lends tag) the @constructs tag allows you to document that a particular function will be used to construct instances of that class.","title":"Overview"},{"location":"tags/constructs/#syntax","text":"@constructs [<name>]","title":"Syntax"},{"location":"tags/constructs/#examples","text":"{% example \"Using the @constructs tag with @lends\" %} var Person = makeClass( /** @lends Person.prototype */ { /** @constructs */ initialize: function(name) { this.name = name; }, /** Describe me. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} {% example \"Without @lends you must provide the name of the class\" %} makeClass('Menu', /** * @constructs Menu * @param items */ function (items) { }, { /** @memberof Menu# */ show: function(){ } } ); {% endexample %}","title":"Examples"},{"location":"tags/copyright/","text":"Syntax @copyright <some copyright text> Overview The @copyright tag is used to document copyright information in a file overview comment. Use this tag in combination with the @file tag . Examples /** * @file This is my cool script. * @copyright Michael Mathews 2011 */","title":"Copyright"},{"location":"tags/copyright/#syntax","text":"@copyright <some copyright text>","title":"Syntax"},{"location":"tags/copyright/#overview","text":"The @copyright tag is used to document copyright information in a file overview comment. Use this tag in combination with the @file tag .","title":"Overview"},{"location":"tags/copyright/#examples","text":"/** * @file This is my cool script. * @copyright Michael Mathews 2011 */","title":"Examples"},{"location":"tags/default/","text":"Syntax @default [<some value>] Overview The @default tag allows you to document the assigned value of a symbol. You can supply this tag with a value yourself or you can allow JSDoc to automatically document the value from the source code -- only possible when the documented symbol is being assigned a single, simple value that is either: a string, a number, a boolean or null. Examples In this example a constant is documented. The value of the constant is 0xff0000 . By adding the @default tag this value is automatically added to the documentation. {% example \"Document the number value of a constant\" %} /** * @constant * @default */ const RED = 0xff0000; {% endexample %}","title":"Default"},{"location":"tags/default/#syntax","text":"@default [<some value>]","title":"Syntax"},{"location":"tags/default/#overview","text":"The @default tag allows you to document the assigned value of a symbol. You can supply this tag with a value yourself or you can allow JSDoc to automatically document the value from the source code -- only possible when the documented symbol is being assigned a single, simple value that is either: a string, a number, a boolean or null.","title":"Overview"},{"location":"tags/default/#examples","text":"In this example a constant is documented. The value of the constant is 0xff0000 . By adding the @default tag this value is automatically added to the documentation. {% example \"Document the number value of a constant\" %} /** * @constant * @default */ const RED = 0xff0000; {% endexample %}","title":"Examples"},{"location":"tags/deprecated/","text":"Syntax @deprecated [<some text>] Overview The @deprecated tag marks a symbol in your code as being deprecated. Examples You can use the @deprecated tag by itself, or include some text that describes more about the deprecation. {% example \"Document that the old function has been deprecated since version 2.0\" %} /** * @deprecated since version 2.0 */ function old() { } {% endexample %}","title":"Deprecated"},{"location":"tags/deprecated/#syntax","text":"@deprecated [<some text>]","title":"Syntax"},{"location":"tags/deprecated/#overview","text":"The @deprecated tag marks a symbol in your code as being deprecated.","title":"Overview"},{"location":"tags/deprecated/#examples","text":"You can use the @deprecated tag by itself, or include some text that describes more about the deprecation. {% example \"Document that the old function has been deprecated since version 2.0\" %} /** * @deprecated since version 2.0 */ function old() { } {% endexample %}","title":"Examples"},{"location":"tags/description/","text":"Syntax @description <some description> Overview The @description tag allows you to provide a general description of the symbol you are documenting. The description may include HTML markup. It may also include Markdown formatting if the Markdown plugin is enabled. Examples If you describe a symbol at the very beginning of a JSDoc comment, before using any block tags, you may omit the @description tag. {% example \"Describing a symbol without the @description tag\" %} /** * Add two numbers. * @param {number} a * @param {number} b * @returns {number} */ function add(a, b) { return a + b; } {% endexample %} By using the @description tag, you can place the description anywhere in the JSDoc comment. {% example \"Describing a symbol with the @description tag\" %} /** * @param {number} a * @param {number} b * @returns {number} * @description Add two numbers. */ function add(a, b) { return a + b; } {% endexample %} If there's both a description at the beginning of a JSDoc comment and a description provided with the @description tag, the description specified with the @description will override the description at the beginning of the comment.","title":"Description"},{"location":"tags/description/#syntax","text":"@description <some description>","title":"Syntax"},{"location":"tags/description/#overview","text":"The @description tag allows you to provide a general description of the symbol you are documenting. The description may include HTML markup. It may also include Markdown formatting if the Markdown plugin is enabled.","title":"Overview"},{"location":"tags/description/#examples","text":"If you describe a symbol at the very beginning of a JSDoc comment, before using any block tags, you may omit the @description tag. {% example \"Describing a symbol without the @description tag\" %} /** * Add two numbers. * @param {number} a * @param {number} b * @returns {number} */ function add(a, b) { return a + b; } {% endexample %} By using the @description tag, you can place the description anywhere in the JSDoc comment. {% example \"Describing a symbol with the @description tag\" %} /** * @param {number} a * @param {number} b * @returns {number} * @description Add two numbers. */ function add(a, b) { return a + b; } {% endexample %} If there's both a description at the beginning of a JSDoc comment and a description provided with the @description tag, the description specified with the @description will override the description at the beginning of the comment.","title":"Examples"},{"location":"tags/enum/","text":"Syntax @enum [<type>] Overview The @enum tag documents a collection of static properties whose values are all of the same type. An enum is similar a collection of properties, except that an enum is documented in its own doc comment, whereas properties are documented within the doc comment of their container. Often this tag is used with @readonly, as an enum typically represents a collection of constants. Examples This shows how to document an object that represents a value with three possible states. Note that the enum members can have optional descriptions added if you wish. Also you can override the type, as is shown with \"MAYBE\" -- by default enum members will be documented with the same type as the enum itself. {% example \"A numeric enum, representing three states\" %} /** * Enum for tri-state values. * @readonly * @enum {number} */ var triState = { /** The true value */ TRUE: 1, FALSE: -1, /** @type {boolean} */ MAYBE: true }; {% endexample %}","title":"Enum"},{"location":"tags/enum/#syntax","text":"@enum [<type>]","title":"Syntax"},{"location":"tags/enum/#overview","text":"The @enum tag documents a collection of static properties whose values are all of the same type. An enum is similar a collection of properties, except that an enum is documented in its own doc comment, whereas properties are documented within the doc comment of their container. Often this tag is used with @readonly, as an enum typically represents a collection of constants.","title":"Overview"},{"location":"tags/enum/#examples","text":"This shows how to document an object that represents a value with three possible states. Note that the enum members can have optional descriptions added if you wish. Also you can override the type, as is shown with \"MAYBE\" -- by default enum members will be documented with the same type as the enum itself. {% example \"A numeric enum, representing three states\" %} /** * Enum for tri-state values. * @readonly * @enum {number} */ var triState = { /** The true value */ TRUE: 1, FALSE: -1, /** @type {boolean} */ MAYBE: true }; {% endexample %}","title":"Examples"},{"location":"tags/event/","text":"Syntax @event <className>#[event:]<eventName> Overview The @event tag allows you to document an event that can be fired. A typical event is represented by an object with a defined set of properties. Once you have used the @event tag to define a specific type of event, you can use the @fires tag to indicate that a method can fire that event. You can also use the @listens tag to indicate that a symbol listens for the event. JSDoc automatically prepends the namespace event: to each event's name. In general, you must include this namespace when you link to the event in another doclet. (The @fires tag is a notable exception; it allows you to omit the namespace.) Note : JSDoc 3 uses @event doclets to document the content of an event. In contrast, JSDoc Toolkit 2 used @event doclets to identify a function that can be fired when an event of the same name occurs. Examples The following examples show how to document an event in the Hurl class called snowball . The event contains an object with a single property. {% example \"Documenting a function call as an event\" %} /** * Throw a snowball. * * @fires Hurl#snowball */ Hurl.prototype.snowball = function() { /** * Snowball event. * * @event Hurl#snowball * @type {object} * @property {boolean} isPacked - Indicates whether the snowball is tightly packed. */ this.emit('snowball', { isPacked: this._snowball.isPacked }); }; {% endexample %} {% example \"Using a named doclet to document an event\" %} /** * Throw a snowball. * * @fires Hurl#snowball */ Hurl.prototype.snowball = function() { // ... }; /** * Snowball event. * * @event Hurl#snowball * @type {object} * @property {boolean} isPacked - Indicates whether the snowball is tightly packed. */ {% endexample %}","title":"Event"},{"location":"tags/event/#syntax","text":"@event <className>#[event:]<eventName>","title":"Syntax"},{"location":"tags/event/#overview","text":"The @event tag allows you to document an event that can be fired. A typical event is represented by an object with a defined set of properties. Once you have used the @event tag to define a specific type of event, you can use the @fires tag to indicate that a method can fire that event. You can also use the @listens tag to indicate that a symbol listens for the event. JSDoc automatically prepends the namespace event: to each event's name. In general, you must include this namespace when you link to the event in another doclet. (The @fires tag is a notable exception; it allows you to omit the namespace.) Note : JSDoc 3 uses @event doclets to document the content of an event. In contrast, JSDoc Toolkit 2 used @event doclets to identify a function that can be fired when an event of the same name occurs.","title":"Overview"},{"location":"tags/event/#examples","text":"The following examples show how to document an event in the Hurl class called snowball . The event contains an object with a single property. {% example \"Documenting a function call as an event\" %} /** * Throw a snowball. * * @fires Hurl#snowball */ Hurl.prototype.snowball = function() { /** * Snowball event. * * @event Hurl#snowball * @type {object} * @property {boolean} isPacked - Indicates whether the snowball is tightly packed. */ this.emit('snowball', { isPacked: this._snowball.isPacked }); }; {% endexample %} {% example \"Using a named doclet to document an event\" %} /** * Throw a snowball. * * @fires Hurl#snowball */ Hurl.prototype.snowball = function() { // ... }; /** * Snowball event. * * @event Hurl#snowball * @type {object} * @property {boolean} isPacked - Indicates whether the snowball is tightly packed. */ {% endexample %}","title":"Examples"},{"location":"tags/example/","text":"Overview Provide an example of how to use a documented item. The text that follows this tag will be displayed as highlighted code. Examples Note that a doclet may have multiple examples. {% example \"Documenting examples\" %} /** * Solves equations of the form a * x = b * @example * // returns 2 * globalNS.method1(5, 10); * @example * // returns 3 * globalNS.method(5, 15); * @returns {Number} Returns the value of x for the equation. */ globalNS.method1 = function (a, b) { return b / a; }; {% endexample %} Examples can also be captioned using <caption></caption> after the @example tag. {% example \"Documenting examples with a caption\" %} /** * Solves equations of the form a * x = b * @example &lt;caption>Example usage of method1.&lt;/caption> * // returns 2 * globalNS.method1(5, 10); * @returns {Number} Returns the value of x for the equation. */ globalNS.method1 = function (a, b) { return b / a; }; {% endexample %}","title":"Example"},{"location":"tags/example/#overview","text":"Provide an example of how to use a documented item. The text that follows this tag will be displayed as highlighted code.","title":"Overview"},{"location":"tags/example/#examples","text":"Note that a doclet may have multiple examples. {% example \"Documenting examples\" %} /** * Solves equations of the form a * x = b * @example * // returns 2 * globalNS.method1(5, 10); * @example * // returns 3 * globalNS.method(5, 15); * @returns {Number} Returns the value of x for the equation. */ globalNS.method1 = function (a, b) { return b / a; }; {% endexample %} Examples can also be captioned using <caption></caption> after the @example tag. {% example \"Documenting examples with a caption\" %} /** * Solves equations of the form a * x = b * @example &lt;caption>Example usage of method1.&lt;/caption> * // returns 2 * globalNS.method1(5, 10); * @returns {Number} Returns the value of x for the equation. */ globalNS.method1 = function (a, b) { return b / a; }; {% endexample %}","title":"Examples"},{"location":"tags/exports/","text":"Syntax @exports <moduleName> In JSDoc 3.3.0 and later, <moduleName> may include the module: prefix. In previous versions, you must omit this prefix. Overview Use the @exports tag when documenting JavaScript modules that export anything other than the \"exports\" object or the \"module.exports\" property. Examples In modules where you are using the special \"exports\" object, the @exports tag is never needed. JSDoc automatically recognizes that this object's members are being exported. Similarly, JSDoc automatically recognizes the special \"module.exports\" property in Node.js modules. {% example \"CommonJS module\" %} /** * A module that says hello! * @module hello/world */ /** Say hello. */ exports.sayHello = function() { return 'Hello world'; }; {% endexample %} {% example \"Node.js module\" %} /** * A module that shouts hello! * @module hello/world */ /** SAY HELLO. */ module.exports = function() { return \"HELLO WORLD\"; }; {% endexample %} {% example \"AMD module that exports an object literal\" %} define(function() { /** * A module that whispers hello! * @module hello/world */ var exports = {}; /** say hello. */ exports.sayHello = function() { return 'hello world'; }; return exports; }); {% endexample %} {% example \"AMD module that exports a constructor\" %} define(function() { /** * A module that creates greeters. * @module greeter */ /** * @constructor * @param {string} subject - The subject to greet. */ var exports = function(subject) { this.subject = subject || 'world'; }; /** Say hello to the subject. */ exports.prototype.sayHello = function() { return 'Hello ' + this.subject; }; return exports; }); {% endexample %} If your module exports an object named anything other than \"exports\" or \"module.exports\", use the @exports tag to indicate what is being exported. {% example \"AMD module that exports an object\" %} define(function () { /** * A module that says hello! * @exports hello/world */ var ns = {}; /** Say hello. */ ns.sayHello = function() { return 'Hello world'; }; return ns; }); {% endexample %}","title":"Exports"},{"location":"tags/exports/#syntax","text":"@exports <moduleName> In JSDoc 3.3.0 and later, <moduleName> may include the module: prefix. In previous versions, you must omit this prefix.","title":"Syntax"},{"location":"tags/exports/#overview","text":"Use the @exports tag when documenting JavaScript modules that export anything other than the \"exports\" object or the \"module.exports\" property.","title":"Overview"},{"location":"tags/exports/#examples","text":"In modules where you are using the special \"exports\" object, the @exports tag is never needed. JSDoc automatically recognizes that this object's members are being exported. Similarly, JSDoc automatically recognizes the special \"module.exports\" property in Node.js modules. {% example \"CommonJS module\" %} /** * A module that says hello! * @module hello/world */ /** Say hello. */ exports.sayHello = function() { return 'Hello world'; }; {% endexample %} {% example \"Node.js module\" %} /** * A module that shouts hello! * @module hello/world */ /** SAY HELLO. */ module.exports = function() { return \"HELLO WORLD\"; }; {% endexample %} {% example \"AMD module that exports an object literal\" %} define(function() { /** * A module that whispers hello! * @module hello/world */ var exports = {}; /** say hello. */ exports.sayHello = function() { return 'hello world'; }; return exports; }); {% endexample %} {% example \"AMD module that exports a constructor\" %} define(function() { /** * A module that creates greeters. * @module greeter */ /** * @constructor * @param {string} subject - The subject to greet. */ var exports = function(subject) { this.subject = subject || 'world'; }; /** Say hello to the subject. */ exports.prototype.sayHello = function() { return 'Hello ' + this.subject; }; return exports; }); {% endexample %} If your module exports an object named anything other than \"exports\" or \"module.exports\", use the @exports tag to indicate what is being exported. {% example \"AMD module that exports an object\" %} define(function () { /** * A module that says hello! * @exports hello/world */ var ns = {}; /** Say hello. */ ns.sayHello = function() { return 'Hello world'; }; return ns; }); {% endexample %}","title":"Examples"},{"location":"tags/external/","text":"Syntax @external <NameOfExternal> Overview The @external tag identifies a class, namespace, or module that is defined outside of the current package. By using this tag, you can document your package's extensions to the external symbol, or you can provide information about the external symbol to your package's users. You can also refer to the external symbol's namepath in any other JSDoc tag. The namepath for an external symbol always uses the prefix external: (for example, {@link external:Foo} or @augments external:Foo ). However, you can omit this prefix from the @external tag. Note : You should only add the @external tag to the highest-level symbol that is defined outside of your project. See \" Documenting a nested external symbol \" for an example. Examples The following example shows how to document the built-in String object as an external, along with the new instance method external:String#rot13 : {% example \"Documenting methods added to built-in classes\" %} /** * The built in string object. * @external String * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String} */ /** * Create a ROT13-encoded version of the string. Added by the `foo` package. * @function external:String#rot13 * @example * var greeting = new String('hello world'); * console.log( greeting.rot13() ); // uryyb jbeyq */ {% endexample %} The following example documents a new starfairy function added to the external namespace \"jQuery.fn\" : {% example \"Documenting external namespaces\" %} /** * The jQuery plugin namespace. * @external \"jQuery.fn\" * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins} */ /** * A jQuery plugin to make stars fly around your home page. * @function external:\"jQuery.fn\".starfairy */ {% endexample %} In the following example, the class EncryptedRequest is documented as a subclass of the built-in class XMLHttpRequest : {% example \"Extending an external.\" %} /** * The built-in class for sending HTTP requests. * @external XMLHttpRequest * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest */ /** * Extends the built-in `XMLHttpRequest` class to send data encoded with a secret key. * @class EncodedRequest * @extends external:XMLHttpRequest */ {% endexample %} You should only add the @external tag to the highest-level symbol that is defined outside of your project. In the following example, the documentation refers to the external class security.TLS . As a result, the @external tag is used to document the external namespace external:security , but not the external class external:security.TLS . {% example \"Documenting a nested external symbol\" %} /** * External namespace for security-related classes. * @external security * @see http://example.org/docs/security */ /** * External class that provides Transport Layer Security (TLS) encryption. * @class TLS * @memberof external:security */ {% endexample %}","title":"External"},{"location":"tags/external/#syntax","text":"@external <NameOfExternal>","title":"Syntax"},{"location":"tags/external/#overview","text":"The @external tag identifies a class, namespace, or module that is defined outside of the current package. By using this tag, you can document your package's extensions to the external symbol, or you can provide information about the external symbol to your package's users. You can also refer to the external symbol's namepath in any other JSDoc tag. The namepath for an external symbol always uses the prefix external: (for example, {@link external:Foo} or @augments external:Foo ). However, you can omit this prefix from the @external tag. Note : You should only add the @external tag to the highest-level symbol that is defined outside of your project. See \" Documenting a nested external symbol \" for an example.","title":"Overview"},{"location":"tags/external/#examples","text":"The following example shows how to document the built-in String object as an external, along with the new instance method external:String#rot13 : {% example \"Documenting methods added to built-in classes\" %} /** * The built in string object. * @external String * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String|String} */ /** * Create a ROT13-encoded version of the string. Added by the `foo` package. * @function external:String#rot13 * @example * var greeting = new String('hello world'); * console.log( greeting.rot13() ); // uryyb jbeyq */ {% endexample %} The following example documents a new starfairy function added to the external namespace \"jQuery.fn\" : {% example \"Documenting external namespaces\" %} /** * The jQuery plugin namespace. * @external \"jQuery.fn\" * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins} */ /** * A jQuery plugin to make stars fly around your home page. * @function external:\"jQuery.fn\".starfairy */ {% endexample %} In the following example, the class EncryptedRequest is documented as a subclass of the built-in class XMLHttpRequest : {% example \"Extending an external.\" %} /** * The built-in class for sending HTTP requests. * @external XMLHttpRequest * @see https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest */ /** * Extends the built-in `XMLHttpRequest` class to send data encoded with a secret key. * @class EncodedRequest * @extends external:XMLHttpRequest */ {% endexample %} You should only add the @external tag to the highest-level symbol that is defined outside of your project. In the following example, the documentation refers to the external class security.TLS . As a result, the @external tag is used to document the external namespace external:security , but not the external class external:security.TLS . {% example \"Documenting a nested external symbol\" %} /** * External namespace for security-related classes. * @external security * @see http://example.org/docs/security */ /** * External class that provides Transport Layer Security (TLS) encryption. * @class TLS * @memberof external:security */ {% endexample %}","title":"Examples"},{"location":"tags/file/","text":"Overview The @file tag provides a description for a file. Use the tag in a JSDoc comment at the beginning of the file. Example {% example \"File description\" %} /** * @file Manages the configuration settings for the widget. * @author Rowina Sanela <rsanela@example.com> */ {% endexample %}","title":"File"},{"location":"tags/file/#overview","text":"The @file tag provides a description for a file. Use the tag in a JSDoc comment at the beginning of the file.","title":"Overview"},{"location":"tags/file/#example","text":"{% example \"File description\" %} /** * @file Manages the configuration settings for the widget. * @author Rowina Sanela <rsanela@example.com> */ {% endexample %}","title":"Example"},{"location":"tags/fires/","text":"Syntax @fires <className>#[event:]<eventName> Overview The @fires tag indicates that a method can fire a specified type of event when it is called. Use the @event tag to document the event's content. Examples {% example \"Method that fires a 'drain' event\" %} /** * Drink the milkshake. * * @fires Milkshake#drain */ Milkshake.prototype.drink = function() { // ... }; {% endexample %}","title":"Fires"},{"location":"tags/fires/#syntax","text":"@fires <className>#[event:]<eventName>","title":"Syntax"},{"location":"tags/fires/#overview","text":"The @fires tag indicates that a method can fire a specified type of event when it is called. Use the @event tag to document the event's content.","title":"Overview"},{"location":"tags/fires/#examples","text":"{% example \"Method that fires a 'drain' event\" %} /** * Drink the milkshake. * * @fires Milkshake#drain */ Milkshake.prototype.drink = function() { // ... }; {% endexample %}","title":"Examples"},{"location":"tags/function/","text":"Syntax @function [<FunctionName>] Overview This marks an object as being a function, even though it may not appear to be one to the parser. It sets the doclet's @kind to 'function'. Examples {% example \"Using @function to mark a function.\" %} /** @function */ var paginate = paginateFactory(pages); {% endexample %} Without the @function tag, the paginate object would be documented as a generic object (a @member ), because it isn't possible to tell from examining the line of code what type of value paginate will hold when it is run. {% example \"Using @function with a name.\" %} /** @function myFunction */ // the above is the same as: /** @function * @name myFunction */ {% endexample %}","title":"Function"},{"location":"tags/function/#syntax","text":"@function [<FunctionName>]","title":"Syntax"},{"location":"tags/function/#overview","text":"This marks an object as being a function, even though it may not appear to be one to the parser. It sets the doclet's @kind to 'function'.","title":"Overview"},{"location":"tags/function/#examples","text":"{% example \"Using @function to mark a function.\" %} /** @function */ var paginate = paginateFactory(pages); {% endexample %} Without the @function tag, the paginate object would be documented as a generic object (a @member ), because it isn't possible to tell from examining the line of code what type of value paginate will hold when it is run. {% example \"Using @function with a name.\" %} /** @function myFunction */ // the above is the same as: /** @function * @name myFunction */ {% endexample %}","title":"Examples"},{"location":"tags/generator/","text":"Syntax @generator Overview The @generator tag indicates that a function is a generator function , meaning that it was declared using the syntax function* foo() {} . This tag is available in JSDoc 3.5.0 and later. In general, you do not need to use this tag, because JSDoc automatically detects generator functions and identifies them in the generated documentation. However, if you are writing a virtual comment for a generator function that does not appear in your code, you can use this tag to tell JSDoc that the function is a generator function. Example The following example shows a virtual comment that uses the @generator tag: {% example \"Virtual comment with @generator tag\" %} /** * Generate numbers in the Fibonacci sequence. * * @generator * @function fibonacci * @yields {number} The next number in the Fibonacci sequence. */ {% endexample %}","title":"Generator"},{"location":"tags/generator/#syntax","text":"@generator","title":"Syntax"},{"location":"tags/generator/#overview","text":"The @generator tag indicates that a function is a generator function , meaning that it was declared using the syntax function* foo() {} . This tag is available in JSDoc 3.5.0 and later. In general, you do not need to use this tag, because JSDoc automatically detects generator functions and identifies them in the generated documentation. However, if you are writing a virtual comment for a generator function that does not appear in your code, you can use this tag to tell JSDoc that the function is a generator function.","title":"Overview"},{"location":"tags/generator/#example","text":"The following example shows a virtual comment that uses the @generator tag: {% example \"Virtual comment with @generator tag\" %} /** * Generate numbers in the Fibonacci sequence. * * @generator * @function fibonacci * @yields {number} The next number in the Fibonacci sequence. */ {% endexample %}","title":"Example"},{"location":"tags/global/","text":"Overview The @global tag specifies that a symbol should appear in the documentation as a global symbol. JSDoc ignores the symbol's actual scope within the source file. This tag is especially useful for symbols that are defined locally, then assigned to a global symbol. Examples Use the @global tag to specify that a symbol should be documented as global. {% example \"Document an inner variable as a global\" %} (function() { /** @global */ var foo = 'hello foo'; this.foo = foo; }).apply(window); {% endexample %}","title":"Global"},{"location":"tags/global/#overview","text":"The @global tag specifies that a symbol should appear in the documentation as a global symbol. JSDoc ignores the symbol's actual scope within the source file. This tag is especially useful for symbols that are defined locally, then assigned to a global symbol.","title":"Overview"},{"location":"tags/global/#examples","text":"Use the @global tag to specify that a symbol should be documented as global. {% example \"Document an inner variable as a global\" %} (function() { /** @global */ var foo = 'hello foo'; this.foo = foo; }).apply(window); {% endexample %}","title":"Examples"},{"location":"tags/hideconstructor/","text":"tag: hideconstructor description: Indicate that the constructor should not be displayed. related: - tags-class.html Syntax @hideconstructor Overview The @hideconstructor tag tells JSDoc that the generated documentation should not display the constructor for a class. This tag is available in JSDoc 3.5.0 and later. For pre-ES2015 classes, use this tag in combination with the @class or @constructor tag . For ES2015 classes, use this tag in the JSDoc comment for your constructor. If your class does not have an explicit constructor, use this tag in the JSDoc comment for the class. Examples {% example \"@hideconstructor tag with pre-ES2015 class\" %} /** * @classdesc Toaster singleton. * @class * @hideconstructor */ var Toaster = (function() { var instance = null; function Toaster() {} /** * Toast an item. * * @alias toast * @memberof Toaster * @instance * @param {BreadyThing} item - The item to toast. * @return {Toast} A toasted bready thing. */ Toaster.prototype.toast = function(item) {}; return { /** * Get the Toaster instance. * * @alias Toaster.getInstance * @returns {Toaster} The Toaster instance. */ getInstance: function() { if (instance === null) { instance = new Toaster(); delete instance.constructor; } return instance; } }; })(); {% endexample %} {% example \"@hideconstructor tag with ES2015 class\" %} /** * Waffle iron singleton. */ class WaffleIron { #instance = null; /** * Create the waffle iron. * * @hideconstructor */ constructor() { if (#instance) { return #instance; } /** * Cook a waffle. * * @param {Batter} batter - The waffle batter. * @return {Waffle} The cooked waffle. */ this.cook = function(batter) {}; this.#instance = this; } /** * Get the WaffleIron instance. * * @return {WaffleIron} The WaffleIron instance. */ getInstance() { return new WaffleIron(); } } {% endexample %}","title":"Hideconstructor"},{"location":"tags/hideconstructor/#syntax","text":"@hideconstructor","title":"Syntax"},{"location":"tags/hideconstructor/#overview","text":"The @hideconstructor tag tells JSDoc that the generated documentation should not display the constructor for a class. This tag is available in JSDoc 3.5.0 and later. For pre-ES2015 classes, use this tag in combination with the @class or @constructor tag . For ES2015 classes, use this tag in the JSDoc comment for your constructor. If your class does not have an explicit constructor, use this tag in the JSDoc comment for the class.","title":"Overview"},{"location":"tags/hideconstructor/#examples","text":"{% example \"@hideconstructor tag with pre-ES2015 class\" %} /** * @classdesc Toaster singleton. * @class * @hideconstructor */ var Toaster = (function() { var instance = null; function Toaster() {} /** * Toast an item. * * @alias toast * @memberof Toaster * @instance * @param {BreadyThing} item - The item to toast. * @return {Toast} A toasted bready thing. */ Toaster.prototype.toast = function(item) {}; return { /** * Get the Toaster instance. * * @alias Toaster.getInstance * @returns {Toaster} The Toaster instance. */ getInstance: function() { if (instance === null) { instance = new Toaster(); delete instance.constructor; } return instance; } }; })(); {% endexample %} {% example \"@hideconstructor tag with ES2015 class\" %} /** * Waffle iron singleton. */ class WaffleIron { #instance = null; /** * Create the waffle iron. * * @hideconstructor */ constructor() { if (#instance) { return #instance; } /** * Cook a waffle. * * @param {Batter} batter - The waffle batter. * @return {Waffle} The cooked waffle. */ this.cook = function(batter) {}; this.#instance = this; } /** * Get the WaffleIron instance. * * @return {WaffleIron} The WaffleIron instance. */ getInstance() { return new WaffleIron(); } } {% endexample %}","title":"Examples"},{"location":"tags/ignore/","text":"Overview The @ignore tag indicates that a symbol in your code should never appear in the documentation. This tag takes precedence over all others. For most JSDoc templates, including the default template, the @ignore tag has the following effects: If you use the @ignore tag with the @class or @module tag, the entire class or module will be omitted from the documentation. If you use the @ignore tag with the @namespace tag, you must also add the @ignore tag to any child classes and namespaces. Otherwise, your documentation will show the child classes and namespaces, but with incomplete names. Examples In the following example, Jacket and Jacket#color will not appear in the documentation. {% example \"Class with @ignore tag\" %} /** * @class * @ignore */ function Jacket() { /** The jacket's color. */ this.color = null; } {% endexample %} In the following example, the Clothes namespace contains a Jacket class. The @ignore tag must be added to both Clothes and Clothes.Jacket . Clothes , Clothes.Jacket , and Clothes.Jacket#color will not appear in the documentation. {% example \"Namespace with child class\" %} /** * @namespace * @ignore */ var Clothes = { /** * @class * @ignore */ Jacket: function() { /** The jacket's color. */ this.color = null; } }; {% endexample %}","title":"Ignore"},{"location":"tags/ignore/#overview","text":"The @ignore tag indicates that a symbol in your code should never appear in the documentation. This tag takes precedence over all others. For most JSDoc templates, including the default template, the @ignore tag has the following effects: If you use the @ignore tag with the @class or @module tag, the entire class or module will be omitted from the documentation. If you use the @ignore tag with the @namespace tag, you must also add the @ignore tag to any child classes and namespaces. Otherwise, your documentation will show the child classes and namespaces, but with incomplete names.","title":"Overview"},{"location":"tags/ignore/#examples","text":"In the following example, Jacket and Jacket#color will not appear in the documentation. {% example \"Class with @ignore tag\" %} /** * @class * @ignore */ function Jacket() { /** The jacket's color. */ this.color = null; } {% endexample %} In the following example, the Clothes namespace contains a Jacket class. The @ignore tag must be added to both Clothes and Clothes.Jacket . Clothes , Clothes.Jacket , and Clothes.Jacket#color will not appear in the documentation. {% example \"Namespace with child class\" %} /** * @namespace * @ignore */ var Clothes = { /** * @class * @ignore */ Jacket: function() { /** The jacket's color. */ this.color = null; } }; {% endexample %}","title":"Examples"},{"location":"tags/implements/","text":"Syntax @implements {typeExpression} Overview The @implements tag indicates that a symbol implements an interface. Add the @implements tag to the top-level symbol that implements the interface (for example, a constructor function). You do not need to add the @implements tag to each member of the implementation (for example, the implementation's instance methods). If you do not document one of the symbols in the implementation, JSDoc will automatically use the interface's documentation for that symbol. Examples In the following example, the TransparentColor class implements the Color interface and adds a TransparentColor#rgba method. {% example \"Using the @implements tag\" %} /** * Interface for classes that represent a color. * * @interface */ function Color() {} /** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * * @returns {Array&lt;number>} An array containing the red, green, and blue values, * in that order. */ Color.prototype.rgb = function() { throw new Error('not implemented'); }; /** * Class representing a color with transparency information. * * @class * @implements {Color} */ function TransparentColor() {} // inherits the documentation from `Color#rgb` TransparentColor.prototype.rgb = function() { // ... }; /** * Get the color as an array of red, green, blue, and alpha values, represented * as decimal numbers between 0 and 1. * * @returns {Array&lt;number>} An array containing the red, green, blue, and alpha * values, in that order. */ TransparentColor.prototype.rgba = function() { // ... }; {% endexample %}","title":"Implements"},{"location":"tags/implements/#syntax","text":"@implements {typeExpression}","title":"Syntax"},{"location":"tags/implements/#overview","text":"The @implements tag indicates that a symbol implements an interface. Add the @implements tag to the top-level symbol that implements the interface (for example, a constructor function). You do not need to add the @implements tag to each member of the implementation (for example, the implementation's instance methods). If you do not document one of the symbols in the implementation, JSDoc will automatically use the interface's documentation for that symbol.","title":"Overview"},{"location":"tags/implements/#examples","text":"In the following example, the TransparentColor class implements the Color interface and adds a TransparentColor#rgba method. {% example \"Using the @implements tag\" %} /** * Interface for classes that represent a color. * * @interface */ function Color() {} /** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * * @returns {Array&lt;number>} An array containing the red, green, and blue values, * in that order. */ Color.prototype.rgb = function() { throw new Error('not implemented'); }; /** * Class representing a color with transparency information. * * @class * @implements {Color} */ function TransparentColor() {} // inherits the documentation from `Color#rgb` TransparentColor.prototype.rgb = function() { // ... }; /** * Get the color as an array of red, green, blue, and alpha values, represented * as decimal numbers between 0 and 1. * * @returns {Array&lt;number>} An array containing the red, green, blue, and alpha * values, in that order. */ TransparentColor.prototype.rgba = function() { // ... }; {% endexample %}","title":"Examples"},{"location":"tags/inheritdoc/","text":"Overview The @inheritdoc tag indicates that a symbol should inherit its documentation from its parent class. Any other tags that you include in the JSDoc comment will be ignored. This tag is provided for compatibility with Closure Compiler . By default, if you do not add a JSDoc comment to a symbol, the symbol will inherit documentation from its parent. The presence of the @inheritdoc tag implies the presence of the @override tag . Examples The following example shows how a class can indicate that it inherits documentation from its parent class: {% example \"Class that inherits from a parent class\" %} /** * @classdesc Abstract class representing a network connection. * @class */ function Connection() {} /** * Open the connection. */ Connection.prototype.open = function() { // ... }; /** * @classdesc Class representing a socket connection. * @class * @augments Connection */ function Socket() {} /** @inheritdoc */ Socket.prototype.open = function() { // ... }; {% endexample %} You can get the same result by omitting the JSDoc comment from Socket#open : {% example \"Inheriting documentation without the @inheritdoc tag\" %} /** * @classdesc Abstract class representing a network connection. * @class */ function Connection() {} /** * Open the connection. */ Connection.prototype.open = function() { // ... }; /** * @classdesc Class representing a socket connection. * @class * @augments Connection */ function Socket() {} Socket.prototype.open = function() { // ... }; {% endexample %}","title":"Inheritdoc"},{"location":"tags/inheritdoc/#overview","text":"The @inheritdoc tag indicates that a symbol should inherit its documentation from its parent class. Any other tags that you include in the JSDoc comment will be ignored. This tag is provided for compatibility with Closure Compiler . By default, if you do not add a JSDoc comment to a symbol, the symbol will inherit documentation from its parent. The presence of the @inheritdoc tag implies the presence of the @override tag .","title":"Overview"},{"location":"tags/inheritdoc/#examples","text":"The following example shows how a class can indicate that it inherits documentation from its parent class: {% example \"Class that inherits from a parent class\" %} /** * @classdesc Abstract class representing a network connection. * @class */ function Connection() {} /** * Open the connection. */ Connection.prototype.open = function() { // ... }; /** * @classdesc Class representing a socket connection. * @class * @augments Connection */ function Socket() {} /** @inheritdoc */ Socket.prototype.open = function() { // ... }; {% endexample %} You can get the same result by omitting the JSDoc comment from Socket#open : {% example \"Inheriting documentation without the @inheritdoc tag\" %} /** * @classdesc Abstract class representing a network connection. * @class */ function Connection() {} /** * Open the connection. */ Connection.prototype.open = function() { // ... }; /** * @classdesc Class representing a socket connection. * @class * @augments Connection */ function Socket() {} Socket.prototype.open = function() { // ... }; {% endexample %}","title":"Examples"},{"location":"tags/inline-link/","text":"Syntax {@link namepathOrURL} [link text]{@link namepathOrURL} {@link namepathOrURL|link text} {@link namepathOrURL link text (after the first space)} Overview The {@link} inline tag creates a link to the namepath or URL that you specify. When you use the {@link} tag, you can also provide link text, using one of several different formats. If you don't provide any link text, JSDoc uses the namepath or URL as the link text. If you need to link to a tutorial, use the {@tutorial} inline tag instead of the {@link} tag. Link formatting By default, {@link} generates standard HTML anchor tags. However, you may prefer to render certain links in a monospace font, or to specify the format of individual links. You can use the following synonyms for the {@link} tag to control the formatting of links: {@linkcode} : Forces the link's text to use a monospace font. {@linkplain} : Forces the link's text to appear as normal text, without a monospace font. You can also set one of the following options in JSDoc's configuration file; see Configuring JSDoc for more details: templates.cleverLinks : When set to true , links to URLs use normal text, and links to code use a monospace font. templates.monospaceLinks : When set to true , all links use a monospace font, except for links created with the {@linkplain} tag. Note : Although the default JSDoc template renders all of these tags correctly, other templates may not recognize the {@linkcode} and {@linkplain} tags. In addition, other templates may ignore the configuration options for link rendering. Examples The following example shows all of the ways to provide link text for the {@link} tag: {% example \"Providing link text\" %} /** * See {@link MyClass} and [MyClass's foo property]{@link MyClass#foo}. * Also, check out {@link http://www.google.com|Google} and * {@link https://github.com GitHub}. */ function myFunction() {} {% endexample %} By default, the example above produces output similar to the following: {% example \"Output for {@link} tags\" %} See &lt;a href=\"MyClass.html\">MyClass&lt;/a> and &lt;a href=\"MyClass.html#foo\">MyClass's foo property&lt;/a>. Also, check out &lt;a href=\"http://www.google.com\">Google&lt;/a> and &lt;a href=\"https://github.com\">GitHub&lt;/a>. {% endexample %} If the configuration property templates.cleverLinks were set to true , the example above would produce the following output: {% example \"Output with clever links enabled\" %} See &lt;a href=\"MyClass.html\">&lt;code>MyClass&lt;/code>&lt;/a> and &lt;a href=\"MyClass.html#foo\"> &lt;code>MyClass's foo property&lt;/code>&lt;/a>. Also, check out &lt;a href=\"http://www.google.com\">Google&lt;/a> and &lt;a href=\"https://github.com\">GitHub&lt;/a>. {% endexample %}","title":"Inline link"},{"location":"tags/inline-link/#syntax","text":"{@link namepathOrURL} [link text]{@link namepathOrURL} {@link namepathOrURL|link text} {@link namepathOrURL link text (after the first space)}","title":"Syntax"},{"location":"tags/inline-link/#overview","text":"The {@link} inline tag creates a link to the namepath or URL that you specify. When you use the {@link} tag, you can also provide link text, using one of several different formats. If you don't provide any link text, JSDoc uses the namepath or URL as the link text. If you need to link to a tutorial, use the {@tutorial} inline tag instead of the {@link} tag.","title":"Overview"},{"location":"tags/inline-link/#link-formatting","text":"By default, {@link} generates standard HTML anchor tags. However, you may prefer to render certain links in a monospace font, or to specify the format of individual links. You can use the following synonyms for the {@link} tag to control the formatting of links: {@linkcode} : Forces the link's text to use a monospace font. {@linkplain} : Forces the link's text to appear as normal text, without a monospace font. You can also set one of the following options in JSDoc's configuration file; see Configuring JSDoc for more details: templates.cleverLinks : When set to true , links to URLs use normal text, and links to code use a monospace font. templates.monospaceLinks : When set to true , all links use a monospace font, except for links created with the {@linkplain} tag. Note : Although the default JSDoc template renders all of these tags correctly, other templates may not recognize the {@linkcode} and {@linkplain} tags. In addition, other templates may ignore the configuration options for link rendering.","title":"Link formatting"},{"location":"tags/inline-link/#examples","text":"The following example shows all of the ways to provide link text for the {@link} tag: {% example \"Providing link text\" %} /** * See {@link MyClass} and [MyClass's foo property]{@link MyClass#foo}. * Also, check out {@link http://www.google.com|Google} and * {@link https://github.com GitHub}. */ function myFunction() {} {% endexample %} By default, the example above produces output similar to the following: {% example \"Output for {@link} tags\" %} See &lt;a href=\"MyClass.html\">MyClass&lt;/a> and &lt;a href=\"MyClass.html#foo\">MyClass's foo property&lt;/a>. Also, check out &lt;a href=\"http://www.google.com\">Google&lt;/a> and &lt;a href=\"https://github.com\">GitHub&lt;/a>. {% endexample %} If the configuration property templates.cleverLinks were set to true , the example above would produce the following output: {% example \"Output with clever links enabled\" %} See &lt;a href=\"MyClass.html\">&lt;code>MyClass&lt;/code>&lt;/a> and &lt;a href=\"MyClass.html#foo\"> &lt;code>MyClass's foo property&lt;/code>&lt;/a>. Also, check out &lt;a href=\"http://www.google.com\">Google&lt;/a> and &lt;a href=\"https://github.com\">GitHub&lt;/a>. {% endexample %}","title":"Examples"},{"location":"tags/inline-tutorial/","text":"Syntax {@tutorial tutorialID} [link text]{@tutorial tutorialID} {@tutorial tutorialID|link text} {@tutorial tutorialID link text (after the first space)} Overview The {@tutorial} inline tag creates a link to the tutorial identifier that you specify. When you use the {@tutorial} tag, you can also provide link text, using one of several different formats. If you don't provide any link text, JSDoc uses the tutorial's title as the link text. If you need to link to a namepath or a URL, use the {@link} inline tag instead of the {@tutorial} tag. Examples The following example shows all of the ways to provide link text for the {@tutorial} tag: {% example \"Providing link text\" %} /** * See {@tutorial gettingstarted} and [Configuring the Dashboard]{@tutorial dashboard}. * For more information, see {@tutorial create|Creating a Widget} and * {@tutorial destroy Destroying a Widget}. */ function myFunction() {} {% endexample %} If all of these tutorials are defined, and the title of the gettingstarted tutorial is \"Getting Started,\" the example above produces output similar to the following: {% example \"Output for {@link} tags\" %} See &lt;a href=\"tutorial-gettingstarted.html\">Getting Started&lt;/a> and &lt;a href=\"tutorial-dashboard.html\">Configuring the Dashboard&lt;/a>. For more information, see &lt;a href=\"tutorial-create.html\">Creating a Widget&lt;/a> and &lt;a href=\"tutorial-destroy.html\">Destroying a Widget&lt;/a>. {% endexample %}","title":"Inline tutorial"},{"location":"tags/inline-tutorial/#syntax","text":"{@tutorial tutorialID} [link text]{@tutorial tutorialID} {@tutorial tutorialID|link text} {@tutorial tutorialID link text (after the first space)}","title":"Syntax"},{"location":"tags/inline-tutorial/#overview","text":"The {@tutorial} inline tag creates a link to the tutorial identifier that you specify. When you use the {@tutorial} tag, you can also provide link text, using one of several different formats. If you don't provide any link text, JSDoc uses the tutorial's title as the link text. If you need to link to a namepath or a URL, use the {@link} inline tag instead of the {@tutorial} tag.","title":"Overview"},{"location":"tags/inline-tutorial/#examples","text":"The following example shows all of the ways to provide link text for the {@tutorial} tag: {% example \"Providing link text\" %} /** * See {@tutorial gettingstarted} and [Configuring the Dashboard]{@tutorial dashboard}. * For more information, see {@tutorial create|Creating a Widget} and * {@tutorial destroy Destroying a Widget}. */ function myFunction() {} {% endexample %} If all of these tutorials are defined, and the title of the gettingstarted tutorial is \"Getting Started,\" the example above produces output similar to the following: {% example \"Output for {@link} tags\" %} See &lt;a href=\"tutorial-gettingstarted.html\">Getting Started&lt;/a> and &lt;a href=\"tutorial-dashboard.html\">Configuring the Dashboard&lt;/a>. For more information, see &lt;a href=\"tutorial-create.html\">Creating a Widget&lt;/a> and &lt;a href=\"tutorial-destroy.html\">Destroying a Widget&lt;/a>. {% endexample %}","title":"Examples"},{"location":"tags/inner/","text":"Overview Using the @inner tag will mark a symbol as an inner member of its parent symbol. This means it can be referred to by \"Parent~Child\". Using @inner will override a doclet's default scope (unless it is in the global scope, in which case it will remain global). Examples {% example \"Using @inner to make a virtual doclet an inner member\" %} /** @namespace MyNamespace */ /** * myFunction is now MyNamespace~myFunction. * @function myFunction * @memberof MyNamespace * @inner */ {% endexample %} Note that in the above we could have used \"@function MyNamespace~myFunction\" instead of the @memberof and @inner tags. {% example \"Using @inner\" %} /** @namespace */ var MyNamespace = { /** * foo is now MyNamespace~foo rather than MyNamespace.foo. * @inner */ foo: 1 }; {% endexample %} In the above example, we use @inner to force a member of a namespace to be documented as an inner member (by default, it would be a static member). This means that foo now has the longname MyNamespace~foo instead of MyNamespace.foo .","title":"Inner"},{"location":"tags/inner/#overview","text":"Using the @inner tag will mark a symbol as an inner member of its parent symbol. This means it can be referred to by \"Parent~Child\". Using @inner will override a doclet's default scope (unless it is in the global scope, in which case it will remain global).","title":"Overview"},{"location":"tags/inner/#examples","text":"{% example \"Using @inner to make a virtual doclet an inner member\" %} /** @namespace MyNamespace */ /** * myFunction is now MyNamespace~myFunction. * @function myFunction * @memberof MyNamespace * @inner */ {% endexample %} Note that in the above we could have used \"@function MyNamespace~myFunction\" instead of the @memberof and @inner tags. {% example \"Using @inner\" %} /** @namespace */ var MyNamespace = { /** * foo is now MyNamespace~foo rather than MyNamespace.foo. * @inner */ foo: 1 }; {% endexample %} In the above example, we use @inner to force a member of a namespace to be documented as an inner member (by default, it would be a static member). This means that foo now has the longname MyNamespace~foo instead of MyNamespace.foo .","title":"Examples"},{"location":"tags/instance/","text":"Overview Using the @instance tag will mark a symbol as an instance member of its parent symbol. This means it can be referred to by \"Parent#Child\". Using @instance will override a doclet's default scope (unless it is in the global scope, in which case it will remain global). Examples The following example is a longhand way of writing \"@function MyNamespace#myFunction\": {% example \"Using @instance to make a virtual doclet an instance member\" %} /** @namespace MyNamespace */ /** * myFunction is now MyNamespace#myFunction. * @function myFunction * @memberof MyNamespace * @instance */ {% endexample %} More usefully, you can use the @instance tag to override the scope that JSDoc infers. For example, you can indicate that a static member is used as an instance member: {% example \"Using @instance to identify an instance member\" %} /** @namespace */ var BaseObject = { /** * foo is now BaseObject#foo rather than BaseObject.foo. * @instance */ foo: null }; /** Generates BaseObject instances. */ function fooFactory(fooValue) { var props = { foo: fooValue }; return Object.create(BaseObject, props); } {% endexample %}","title":"Instance"},{"location":"tags/instance/#overview","text":"Using the @instance tag will mark a symbol as an instance member of its parent symbol. This means it can be referred to by \"Parent#Child\". Using @instance will override a doclet's default scope (unless it is in the global scope, in which case it will remain global).","title":"Overview"},{"location":"tags/instance/#examples","text":"The following example is a longhand way of writing \"@function MyNamespace#myFunction\": {% example \"Using @instance to make a virtual doclet an instance member\" %} /** @namespace MyNamespace */ /** * myFunction is now MyNamespace#myFunction. * @function myFunction * @memberof MyNamespace * @instance */ {% endexample %} More usefully, you can use the @instance tag to override the scope that JSDoc infers. For example, you can indicate that a static member is used as an instance member: {% example \"Using @instance to identify an instance member\" %} /** @namespace */ var BaseObject = { /** * foo is now BaseObject#foo rather than BaseObject.foo. * @instance */ foo: null }; /** Generates BaseObject instances. */ function fooFactory(fooValue) { var props = { foo: fooValue }; return Object.create(BaseObject, props); } {% endexample %}","title":"Examples"},{"location":"tags/interface/","text":"Syntax With the JSDoc tag dictionary (enabled by default): @interface [<name>] With the Closure Compiler tag dictionary: @interface Overview The @interface tag marks a symbol as an interface that other symbols can implement. For example, your code might define a parent class whose methods and properties are stubbed out. You can add the @interface tag to the parent class to indicate that child classes must implement the parent class' methods and properties. Add the @interface tag to the top-level symbol for the interface (for example, a constructor function). You do not need to add the @interface tag to each member of the interface (for example, the interface's instance methods). If you are using the JSDoc tag dictionary (enabled by default), you can also define an interface with virtual comments, rather than by writing code for the interface. See \" Virtual comments that define an interface \" for an example. Examples In the following example, the Color function represents an interface that other classes can implement: {% example \"Using the @interface tag\" %} /** * Interface for classes that represent a color. * * @interface */ function Color() {} /** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * * @returns {Array&lt;number>} An array containing the red, green, and blue values, * in that order. */ Color.prototype.rgb = function() { throw new Error('not implemented'); }; {% endexample %} The following example uses virtual comments, rather than code, to define the Color interface: {% example \"Virtual comments that define an interface\" %} /** * Interface for classes that represent a color. * * @interface Color */ /** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * * @function * @name Color#rgb * @returns {Array&lt;number>} An array containing the red, green, and blue values, * in that order. */ {% endexample %}","title":"Interface"},{"location":"tags/interface/#syntax","text":"With the JSDoc tag dictionary (enabled by default): @interface [<name>] With the Closure Compiler tag dictionary: @interface","title":"Syntax"},{"location":"tags/interface/#overview","text":"The @interface tag marks a symbol as an interface that other symbols can implement. For example, your code might define a parent class whose methods and properties are stubbed out. You can add the @interface tag to the parent class to indicate that child classes must implement the parent class' methods and properties. Add the @interface tag to the top-level symbol for the interface (for example, a constructor function). You do not need to add the @interface tag to each member of the interface (for example, the interface's instance methods). If you are using the JSDoc tag dictionary (enabled by default), you can also define an interface with virtual comments, rather than by writing code for the interface. See \" Virtual comments that define an interface \" for an example.","title":"Overview"},{"location":"tags/interface/#examples","text":"In the following example, the Color function represents an interface that other classes can implement: {% example \"Using the @interface tag\" %} /** * Interface for classes that represent a color. * * @interface */ function Color() {} /** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * * @returns {Array&lt;number>} An array containing the red, green, and blue values, * in that order. */ Color.prototype.rgb = function() { throw new Error('not implemented'); }; {% endexample %} The following example uses virtual comments, rather than code, to define the Color interface: {% example \"Virtual comments that define an interface\" %} /** * Interface for classes that represent a color. * * @interface Color */ /** * Get the color as an array of red, green, and blue values, represented as * decimal numbers between 0 and 1. * * @function * @name Color#rgb * @returns {Array&lt;number>} An array containing the red, green, and blue values, * in that order. */ {% endexample %}","title":"Examples"},{"location":"tags/kind/","text":"Syntax @kind <kindName> where <kindName> is one of: class constant event external file function member mixin module namespace typedef Overview The @kind tag is used to document what kind of symbol is being documented (for example, a class or a module). The kind of symbol differs from a symbol's type (for example, string or boolean). Usually you do not need the @kind tag, because the symbol's kind is determined by other tags in the doclet. For example, using the @class tag automatically implies \"@kind class\", and using the @namespace tag implies \"@kind namespace\". Examples {% example \"Using @kind\" %} // The following examples produce the same result: /** * A constant. * @kind constant */ const asdf = 1; /** * A constant. * @constant */ const asdf = 1; {% endexample %} In the case of tags with conflicting kinds (for example, using both @module, which sets the kind to \"module\", and \"@kind constant\" which sets the kind to \"constant\"), the last tag determines the kind. {% example \"Conflicting @kind statements\" %} /** * This will show up as a constant * @module myModule * @kind constant */ /** * This will show up as a module. * @kind constant * @module myModule */ {% endexample %}","title":"Kind"},{"location":"tags/kind/#syntax","text":"@kind <kindName> where <kindName> is one of: class constant event external file function member mixin module namespace typedef","title":"Syntax"},{"location":"tags/kind/#overview","text":"The @kind tag is used to document what kind of symbol is being documented (for example, a class or a module). The kind of symbol differs from a symbol's type (for example, string or boolean). Usually you do not need the @kind tag, because the symbol's kind is determined by other tags in the doclet. For example, using the @class tag automatically implies \"@kind class\", and using the @namespace tag implies \"@kind namespace\".","title":"Overview"},{"location":"tags/kind/#examples","text":"{% example \"Using @kind\" %} // The following examples produce the same result: /** * A constant. * @kind constant */ const asdf = 1; /** * A constant. * @constant */ const asdf = 1; {% endexample %} In the case of tags with conflicting kinds (for example, using both @module, which sets the kind to \"module\", and \"@kind constant\" which sets the kind to \"constant\"), the last tag determines the kind. {% example \"Conflicting @kind statements\" %} /** * This will show up as a constant * @module myModule * @kind constant */ /** * This will show up as a module. * @kind constant * @module myModule */ {% endexample %}","title":"Examples"},{"location":"tags/lends/","text":"Syntax @lends <namepath> Overview The @lends tag allows you to document all the members of an object literal as if they were members of a symbol with the given name. You might want to do this if you are passing an object literal into a function that creates a named class from its members. Examples In this example, we want to use a helper function to make a class named Person , along with instance methods named initialize and say . This is similar to how some popular frameworks handle class creation. {% example \"Example class\" %} // We want to document this as being a class var Person = makeClass( // We want to document these as being methods { initialize: function(name) { this.name = name; }, say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} Without any comments, JSDoc won't recognize that this code creates a Person class with two methods. To document the methods, we must use a @lends tag in a doc comment immediately before the object literal. The @lends tag tells JSDoc that all the member names of that object literal are being \"loaned\" to a variable named Person . We must also add comments to each of the methods. The following example gets us closer to what we want: {% example \"Documented as static methods\" %} /** @class */ var Person = makeClass( /** @lends Person */ { /** * Create a `Person` instance. * @param {string} name - The person's name. */ initialize: function(name) { this.name = name; }, /** * Say something. * @param {string} message - The message to say. * @returns {string} The complete message. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} Now the functions named initialize and say will be documented, but they appear as static methods of the Person class. That is possibly what you meant, but in this case we want initialize and say to belong to the instances of the Person class. So we change things slightly by lending the methods to the class's prototype: {% example \"Documented as instance methods\" %} /** @class */ var Person = makeClass( /** @lends Person.prototype */ { /** * Create a `Person` instance. * @param {string} name - The person's name. */ initialize: function(name) { this.name = name; }, /** * Say something. * @param {string} message - The message to say. * @returns {string} The complete message. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} One final step: Our class framework uses the loaned initialize function to construct Person instances, but a Person instance does not have its own initialize method. The solution is to add the @constructs tag to the loaned function. Remember to remove the @class tag as well, or else two classes will be documented. {% example \"Documented with a constructor\" %} var Person = makeClass( /** @lends Person.prototype */ { /** * Create a `Person` instance. * @constructs * @param {string} name - The person's name. */ initialize: function(name) { this.name = name; }, /** * Say something. * @param {string} message - The message to say. * @returns {string} The complete message. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %}","title":"Lends"},{"location":"tags/lends/#syntax","text":"@lends <namepath>","title":"Syntax"},{"location":"tags/lends/#overview","text":"The @lends tag allows you to document all the members of an object literal as if they were members of a symbol with the given name. You might want to do this if you are passing an object literal into a function that creates a named class from its members.","title":"Overview"},{"location":"tags/lends/#examples","text":"In this example, we want to use a helper function to make a class named Person , along with instance methods named initialize and say . This is similar to how some popular frameworks handle class creation. {% example \"Example class\" %} // We want to document this as being a class var Person = makeClass( // We want to document these as being methods { initialize: function(name) { this.name = name; }, say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} Without any comments, JSDoc won't recognize that this code creates a Person class with two methods. To document the methods, we must use a @lends tag in a doc comment immediately before the object literal. The @lends tag tells JSDoc that all the member names of that object literal are being \"loaned\" to a variable named Person . We must also add comments to each of the methods. The following example gets us closer to what we want: {% example \"Documented as static methods\" %} /** @class */ var Person = makeClass( /** @lends Person */ { /** * Create a `Person` instance. * @param {string} name - The person's name. */ initialize: function(name) { this.name = name; }, /** * Say something. * @param {string} message - The message to say. * @returns {string} The complete message. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} Now the functions named initialize and say will be documented, but they appear as static methods of the Person class. That is possibly what you meant, but in this case we want initialize and say to belong to the instances of the Person class. So we change things slightly by lending the methods to the class's prototype: {% example \"Documented as instance methods\" %} /** @class */ var Person = makeClass( /** @lends Person.prototype */ { /** * Create a `Person` instance. * @param {string} name - The person's name. */ initialize: function(name) { this.name = name; }, /** * Say something. * @param {string} message - The message to say. * @returns {string} The complete message. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %} One final step: Our class framework uses the loaned initialize function to construct Person instances, but a Person instance does not have its own initialize method. The solution is to add the @constructs tag to the loaned function. Remember to remove the @class tag as well, or else two classes will be documented. {% example \"Documented with a constructor\" %} var Person = makeClass( /** @lends Person.prototype */ { /** * Create a `Person` instance. * @constructs * @param {string} name - The person's name. */ initialize: function(name) { this.name = name; }, /** * Say something. * @param {string} message - The message to say. * @returns {string} The complete message. */ say: function(message) { return this.name + \" says: \" + message; } } ); {% endexample %}","title":"Examples"},{"location":"tags/license/","text":"Syntax @license <identifier> Overview The @license tag identifies the software license that applies to any portion of your code. You can use any text to identify the license you are using. If your code uses a standard open-source license, consider using the appropriate identifier from the Software Package Data Exchange (SPDX) License List . Some JavaScript processing tools, such as Google's Closure Compiler, will automatically preserve any JSDoc comment that includes a @license tag. If you are using one of these tools, you may wish to add a standalone JSDoc comment that includes the @license tag, along with the entire text of the license, so that the license text will be included in generated JavaScript files. Examples {% example \"A module that is distributed under the Apache License 2.0\" %} /** * Utility functions for the foo package. * @module foo/util * @license Apache-2.0 */ {% endexample %} {% example \"A standalone JSDoc comment with the complete MIT license\" %} /** * @license * Copyright (c) 2015 Example Corporation Inc. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ {% endexample %}","title":"License"},{"location":"tags/license/#syntax","text":"@license <identifier>","title":"Syntax"},{"location":"tags/license/#overview","text":"The @license tag identifies the software license that applies to any portion of your code. You can use any text to identify the license you are using. If your code uses a standard open-source license, consider using the appropriate identifier from the Software Package Data Exchange (SPDX) License List . Some JavaScript processing tools, such as Google's Closure Compiler, will automatically preserve any JSDoc comment that includes a @license tag. If you are using one of these tools, you may wish to add a standalone JSDoc comment that includes the @license tag, along with the entire text of the license, so that the license text will be included in generated JavaScript files.","title":"Overview"},{"location":"tags/license/#examples","text":"{% example \"A module that is distributed under the Apache License 2.0\" %} /** * Utility functions for the foo package. * @module foo/util * @license Apache-2.0 */ {% endexample %} {% example \"A standalone JSDoc comment with the complete MIT license\" %} /** * @license * Copyright (c) 2015 Example Corporation Inc. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. */ {% endexample %}","title":"Examples"},{"location":"tags/listens/","text":"Syntax @listens <eventName> Overview The @listens tag indicates that a symbol listens for the specified event. Use the @event tag to document the event's content. Example The following example shows how to document an event named module:hurler~event:snowball , as well as a method named module:playground/monitor.reportThrowage that listens for the event. {% example \"Documenting an event and its listener\" %} define('hurler', [], function () { /** * Event reporting that a snowball has been hurled. * * @event module:hurler~snowball * @property {number} velocity - The snowball's velocity, in meters per second. */ /** * Snowball-hurling module. * * @module hurler */ var exports = { /** * Attack an innocent (or guilty) person with a snowball. * * @method * @fires module:hurler~snowball */ attack: function () { this.emit('snowball', { velocity: 10 }); } }; return exports; }); define('playground/monitor', [], function () { /** * Keeps an eye out for snowball-throwers. * * @module playground/monitor */ var exports = { /** * Report the throwing of a snowball. * * @method * @param {module:hurler~event:snowball} e - A snowball event. * @listens module:hurler~event:snowball */ reportThrowage: function (e) { this.log('snowball thrown: velocity ' + e.velocity); } }; return exports; }); {% endexample %}","title":"Listens"},{"location":"tags/listens/#syntax","text":"@listens <eventName>","title":"Syntax"},{"location":"tags/listens/#overview","text":"The @listens tag indicates that a symbol listens for the specified event. Use the @event tag to document the event's content.","title":"Overview"},{"location":"tags/listens/#example","text":"The following example shows how to document an event named module:hurler~event:snowball , as well as a method named module:playground/monitor.reportThrowage that listens for the event. {% example \"Documenting an event and its listener\" %} define('hurler', [], function () { /** * Event reporting that a snowball has been hurled. * * @event module:hurler~snowball * @property {number} velocity - The snowball's velocity, in meters per second. */ /** * Snowball-hurling module. * * @module hurler */ var exports = { /** * Attack an innocent (or guilty) person with a snowball. * * @method * @fires module:hurler~snowball */ attack: function () { this.emit('snowball', { velocity: 10 }); } }; return exports; }); define('playground/monitor', [], function () { /** * Keeps an eye out for snowball-throwers. * * @module playground/monitor */ var exports = { /** * Report the throwing of a snowball. * * @method * @param {module:hurler~event:snowball} e - A snowball event. * @listens module:hurler~event:snowball */ reportThrowage: function (e) { this.log('snowball thrown: velocity ' + e.velocity); } }; return exports; }); {% endexample %}","title":"Example"},{"location":"tags/member/","text":"Syntax @member [<type>] [<name>] Overview The @member tag identifies any member that does not have a more specialized kind, such as \"class\", \"function\", or \"constant\". A member can optionally have a type as well as a name. Examples {% example \"Using @member with Data#point\" %} /** @class */ function Data() { /** @member {Object} */ this.point = {}; } {% endexample %} Here is an example of using @var, a synonym of @member, to document a (virtual) variable 'foo'. {% example \"Using @var to document a virtual member\" %} /** * A variable in the global namespace called 'foo'. * @var {number} foo */ {% endexample %} The above example is equivalent to the following: /** * A variable in the global namespace called 'foo'. * @type {number} */ var foo;","title":"Member"},{"location":"tags/member/#syntax","text":"@member [<type>] [<name>]","title":"Syntax"},{"location":"tags/member/#overview","text":"The @member tag identifies any member that does not have a more specialized kind, such as \"class\", \"function\", or \"constant\". A member can optionally have a type as well as a name.","title":"Overview"},{"location":"tags/member/#examples","text":"{% example \"Using @member with Data#point\" %} /** @class */ function Data() { /** @member {Object} */ this.point = {}; } {% endexample %} Here is an example of using @var, a synonym of @member, to document a (virtual) variable 'foo'. {% example \"Using @var to document a virtual member\" %} /** * A variable in the global namespace called 'foo'. * @var {number} foo */ {% endexample %} The above example is equivalent to the following: /** * A variable in the global namespace called 'foo'. * @type {number} */ var foo;","title":"Examples"},{"location":"tags/memberof/","text":"Syntax @memberof <parentNamepath> @memberof! <parentNamepath> Overview The @memberof tag identifies a member symbol that belongs to a parent symbol. By default, the @memberof tag documents member symbols as static members. For inner and instance members, you can use scoping punctuation after the namepath, or you can add the @inner or @instance tag. The \"forced\" @memberof tag, @memberof!, forces the object to be documented as belonging to a specific parent even if it appears to have a different parent. Examples In the following example, the hammer function would normally be documented as a global function. That's because, in fact, it is a global function, but it is also a member of the Tools namespace, and that's how you wish to document it. The solution is to add a @memberof tag: {% example \"Using @memberof\" %} /** @namespace */ var Tools = {}; /** @memberof Tools */ var hammer = function() { }; Tools.hammer = hammer; {% endexample %} For instance members of a class, use the syntax \"@memberof ClassName.prototype\" or \"@memberof ClassName#\". Alternatively, you can combine \"@memberof ClassName\" with the \"@instance\" tag. {% example \"Using @memberof with a class prototype\" %} /** @class Observable */ create( 'Observable', { /** * This will be a static member, Observable.cache. * @memberof Observable */ cache: [], /** * This will be an instance member, Observable#publish. * @memberof Observable.prototype */ publish: function(msg) {}, /** * This will also be an instance member, Observable#save. * @memberof Observable# */ save: function() {}, /** * This will also be an instance member, Observable#end. * @memberof Observable * @instance */ end: function() {} } ); {% endexample %} The following example uses the forced @memberof tag, \"@memberof!\", to document a property of an object (Data#point) that is an instance member of a class (Data). When you use the @property tag to document a property, you cannot link to the property using its longname. We can force the property to be linkable by using \"@alias\" and \"@memberof!\" to tell JSDoc that Data#point.y should be documented as a member \"point.y\" of \"Data#\", rather than a member \"y\" of \"point\" of \"Data#\". {% example \"Using @memberof! for object properties\" %} /** @class */ function Data() { /** * @type {object} * @property {number} y This will show up as a property of `Data#point`, * but you cannot link to the property as {@link Data#point.y}. */ this.point = { /** * The @alias and @memberof! tags force JSDoc to document the * property as `point.x` (rather than `x`) and to be a member of * `Data#`. You can link to the property as {@link Data#point.x}. * @alias point.x * @memberof! Data# */ x: 0, y: 1 }; } {% endexample %}","title":"Memberof"},{"location":"tags/memberof/#syntax","text":"@memberof <parentNamepath> @memberof! <parentNamepath>","title":"Syntax"},{"location":"tags/memberof/#overview","text":"The @memberof tag identifies a member symbol that belongs to a parent symbol. By default, the @memberof tag documents member symbols as static members. For inner and instance members, you can use scoping punctuation after the namepath, or you can add the @inner or @instance tag. The \"forced\" @memberof tag, @memberof!, forces the object to be documented as belonging to a specific parent even if it appears to have a different parent.","title":"Overview"},{"location":"tags/memberof/#examples","text":"In the following example, the hammer function would normally be documented as a global function. That's because, in fact, it is a global function, but it is also a member of the Tools namespace, and that's how you wish to document it. The solution is to add a @memberof tag: {% example \"Using @memberof\" %} /** @namespace */ var Tools = {}; /** @memberof Tools */ var hammer = function() { }; Tools.hammer = hammer; {% endexample %} For instance members of a class, use the syntax \"@memberof ClassName.prototype\" or \"@memberof ClassName#\". Alternatively, you can combine \"@memberof ClassName\" with the \"@instance\" tag. {% example \"Using @memberof with a class prototype\" %} /** @class Observable */ create( 'Observable', { /** * This will be a static member, Observable.cache. * @memberof Observable */ cache: [], /** * This will be an instance member, Observable#publish. * @memberof Observable.prototype */ publish: function(msg) {}, /** * This will also be an instance member, Observable#save. * @memberof Observable# */ save: function() {}, /** * This will also be an instance member, Observable#end. * @memberof Observable * @instance */ end: function() {} } ); {% endexample %} The following example uses the forced @memberof tag, \"@memberof!\", to document a property of an object (Data#point) that is an instance member of a class (Data). When you use the @property tag to document a property, you cannot link to the property using its longname. We can force the property to be linkable by using \"@alias\" and \"@memberof!\" to tell JSDoc that Data#point.y should be documented as a member \"point.y\" of \"Data#\", rather than a member \"y\" of \"point\" of \"Data#\". {% example \"Using @memberof! for object properties\" %} /** @class */ function Data() { /** * @type {object} * @property {number} y This will show up as a property of `Data#point`, * but you cannot link to the property as {@link Data#point.y}. */ this.point = { /** * The @alias and @memberof! tags force JSDoc to document the * property as `point.x` (rather than `x`) and to be a member of * `Data#`. You can link to the property as {@link Data#point.x}. * @alias point.x * @memberof! Data# */ x: 0, y: 1 }; } {% endexample %}","title":"Examples"},{"location":"tags/mixes/","text":"Syntax @mixes <OtherObjectPath> Overview The @mixes tag indicates that the current object mixes in all the members from OtherObjectPath , which is a @mixin . Examples To start, we document a mixin with the @mixin tag: {% example \"Example of a @mixin\" %} /** * This provides methods used for event handling. It's not meant to * be used directly. * * @mixin */ var Eventful = { /** * Register a handler function to be called whenever this event is fired. * @param {string} eventName - Name of the event. * @param {function(Object)} handler - The handler to call. */ on: function(eventName, handler) { // code... }, /** * Fire an event, causing all handlers for that event name to run. * @param {string} eventName - Name of the event. * @param {Object} eventData - The data provided to each handler. */ fire: function(eventName, eventData) { // code... } }; {% endexample %} Now we add a FormButton class and call a \"mix\" function that mixes all of the Eventful functions into FormButton, so that FormButton can also fire events and have listeners. We use the @mixes tag to indicate that FormButton mixes the Eventful functions. {% example \"Using the @mixes tag\" %} /** * @constructor FormButton * @mixes Eventful */ var FormButton = function() { // code... }; FormButton.prototype.press = function() { this.fire('press', {}); } mix(Eventful).into(FormButton.prototype); {% endexample %}","title":"Mixes"},{"location":"tags/mixes/#syntax","text":"@mixes <OtherObjectPath>","title":"Syntax"},{"location":"tags/mixes/#overview","text":"The @mixes tag indicates that the current object mixes in all the members from OtherObjectPath , which is a @mixin .","title":"Overview"},{"location":"tags/mixes/#examples","text":"To start, we document a mixin with the @mixin tag: {% example \"Example of a @mixin\" %} /** * This provides methods used for event handling. It's not meant to * be used directly. * * @mixin */ var Eventful = { /** * Register a handler function to be called whenever this event is fired. * @param {string} eventName - Name of the event. * @param {function(Object)} handler - The handler to call. */ on: function(eventName, handler) { // code... }, /** * Fire an event, causing all handlers for that event name to run. * @param {string} eventName - Name of the event. * @param {Object} eventData - The data provided to each handler. */ fire: function(eventName, eventData) { // code... } }; {% endexample %} Now we add a FormButton class and call a \"mix\" function that mixes all of the Eventful functions into FormButton, so that FormButton can also fire events and have listeners. We use the @mixes tag to indicate that FormButton mixes the Eventful functions. {% example \"Using the @mixes tag\" %} /** * @constructor FormButton * @mixes Eventful */ var FormButton = function() { // code... }; FormButton.prototype.press = function() { this.fire('press', {}); } mix(Eventful).into(FormButton.prototype); {% endexample %}","title":"Examples"},{"location":"tags/mixin/","text":"Syntax @mixin [<MixinName>] Overview A mixin provides functionality that is intended to be added to other objects. If desired, you can use the @mixin tag to indicate that an object is a mixin. You can then add the @mixes tag to objects that use the mixin. Examples {% example \"Using @mixin\" %} /** * This provides methods used for event handling. It's not meant to * be used directly. * * @mixin */ var Eventful = { /** * Register a handler function to be called whenever this event is fired. * @param {string} eventName - Name of the event. * @param {function(Object)} handler - The handler to call. */ on: function(eventName, handler) { // code... }, /** * Fire an event, causing all handlers for that event name to run. * @param {string} eventName - Name of the event. * @param {Object} eventData - The data provided to each handler. */ fire: function(eventName, eventData) { // code... } }; {% endexample %}","title":"Mixin"},{"location":"tags/mixin/#syntax","text":"@mixin [<MixinName>]","title":"Syntax"},{"location":"tags/mixin/#overview","text":"A mixin provides functionality that is intended to be added to other objects. If desired, you can use the @mixin tag to indicate that an object is a mixin. You can then add the @mixes tag to objects that use the mixin.","title":"Overview"},{"location":"tags/mixin/#examples","text":"{% example \"Using @mixin\" %} /** * This provides methods used for event handling. It's not meant to * be used directly. * * @mixin */ var Eventful = { /** * Register a handler function to be called whenever this event is fired. * @param {string} eventName - Name of the event. * @param {function(Object)} handler - The handler to call. */ on: function(eventName, handler) { // code... }, /** * Fire an event, causing all handlers for that event name to run. * @param {string} eventName - Name of the event. * @param {Object} eventData - The data provided to each handler. */ fire: function(eventName, eventData) { // code... } }; {% endexample %}","title":"Examples"},{"location":"tags/module/","text":"Syntax @module [[{<type>}] <moduleName>] In JSDoc 3.3.0 and later, <moduleName> may include the module: prefix. In previous versions, you must omit this prefix. Note: If you provide a type, you must also provide a name. Overview The @module tag marks the current file as being its own module. All symbols in the file are assumed to be members of the module unless documented otherwise. Link to a module (e.g. within a @link or @see tag) using \"module:moduleName\". For example, \"@module foo/bar\" can be linked to using \"{@link module:foo/bar}\". If the module name is not provided, it is derived from the module's path and filename. For example, suppose I have a file test.js , located in the src directory, that contains the block comment /** @module */ . Here are some scenarios for running JSDoc and the resulting module names for test.js: {% example \"Derived module names if none is provided.\" %} # from src/ jsdoc ./test.js # module name 'test' # from src's parent directory: jsdoc src/test.js # module name 'src/test' jsdoc -r src/ # module name 'test' {% endexample %} Examples The following example shows the namepaths that are used for symbols in a module. The first symbol is a module-private, or \"inner,\" variable--it can be only accessed within the module. The second symbol is a static function that is exported by the module. {% example \"Basic @module use\" %} /** @module myModule */ /** will be module:myModule~foo */ var foo = 1; /** will be module:myModule.bar */ var bar = function() {}; {% endexample %} When an exported symbol is defined as a member of module.exports , exports , or this , JSDoc infers that the symbol is a static member of the module. In the following example, the Book class is documented as a static member, \"module:bookshelf.Book\", with one instance member, \"module:bookshelf.Book#title\". {% example \"Defining exported symbols as a member of 'this'\" %} /** @module bookshelf */ /** @class */ this.Book = function (title) { /** The title. */ this.title = title; }; {% endexample %} In the following example, the two functions have the namepaths \"module:color/mixer.blend\" and \"module:color/mixer.darken\". {% example \"Defining exported symbols as a member of 'module.exports' or 'exports'\" %} /** @module color/mixer */ module.exports = { /** Blend two colours together. */ blend: function (color1, color2) {} }; /** Darkens a color. */ exports.darken = function (color, shade) {}; {% endexample %} See Documenting JavaScript Modules for further examples.","title":"Module"},{"location":"tags/module/#syntax","text":"@module [[{<type>}] <moduleName>] In JSDoc 3.3.0 and later, <moduleName> may include the module: prefix. In previous versions, you must omit this prefix. Note: If you provide a type, you must also provide a name.","title":"Syntax"},{"location":"tags/module/#overview","text":"The @module tag marks the current file as being its own module. All symbols in the file are assumed to be members of the module unless documented otherwise. Link to a module (e.g. within a @link or @see tag) using \"module:moduleName\". For example, \"@module foo/bar\" can be linked to using \"{@link module:foo/bar}\". If the module name is not provided, it is derived from the module's path and filename. For example, suppose I have a file test.js , located in the src directory, that contains the block comment /** @module */ . Here are some scenarios for running JSDoc and the resulting module names for test.js: {% example \"Derived module names if none is provided.\" %} # from src/ jsdoc ./test.js # module name 'test' # from src's parent directory: jsdoc src/test.js # module name 'src/test' jsdoc -r src/ # module name 'test' {% endexample %}","title":"Overview"},{"location":"tags/module/#examples","text":"The following example shows the namepaths that are used for symbols in a module. The first symbol is a module-private, or \"inner,\" variable--it can be only accessed within the module. The second symbol is a static function that is exported by the module. {% example \"Basic @module use\" %} /** @module myModule */ /** will be module:myModule~foo */ var foo = 1; /** will be module:myModule.bar */ var bar = function() {}; {% endexample %} When an exported symbol is defined as a member of module.exports , exports , or this , JSDoc infers that the symbol is a static member of the module. In the following example, the Book class is documented as a static member, \"module:bookshelf.Book\", with one instance member, \"module:bookshelf.Book#title\". {% example \"Defining exported symbols as a member of 'this'\" %} /** @module bookshelf */ /** @class */ this.Book = function (title) { /** The title. */ this.title = title; }; {% endexample %} In the following example, the two functions have the namepaths \"module:color/mixer.blend\" and \"module:color/mixer.darken\". {% example \"Defining exported symbols as a member of 'module.exports' or 'exports'\" %} /** @module color/mixer */ module.exports = { /** Blend two colours together. */ blend: function (color1, color2) {} }; /** Darkens a color. */ exports.darken = function (color, shade) {}; {% endexample %} See Documenting JavaScript Modules for further examples.","title":"Examples"},{"location":"tags/name/","text":"Syntax @name <namePath> Overview The @name tag forces JSDoc to associate the remainder of the JSDoc comment with the given name, ignoring all surrounding code. This tag is best used in \"virtual comments\" for symbols that are not readily visible in the code, such as methods that are generated at runtime. When you use the @name tag, you must provide additional tags that tell JSDoc what kind of symbol you are documenting; whether the symbol is a member of another symbol; and so on. If you do not provide this information, the symbol will not be documented correctly. Warning : By using the @name tag, you are telling JSDoc to ignore the surrounding code and treat your documentation comment in isolation. In many cases, it is best to use the @alias tag instead, which changes a symbol's name in the documentation but preserves other information about the symbol. Examples The following example shows how to use the @name tag to document a function that JSDoc would not normally recognize. {% example \"Using the @name tag\" %} /** * @name highlightSearchTerm * @function * @global * @param {string} term - The search term to highlight. */ eval(\"window.highlightSearchTerm = function(term) {};\") {% endexample %}","title":"Name"},{"location":"tags/name/#syntax","text":"@name <namePath>","title":"Syntax"},{"location":"tags/name/#overview","text":"The @name tag forces JSDoc to associate the remainder of the JSDoc comment with the given name, ignoring all surrounding code. This tag is best used in \"virtual comments\" for symbols that are not readily visible in the code, such as methods that are generated at runtime. When you use the @name tag, you must provide additional tags that tell JSDoc what kind of symbol you are documenting; whether the symbol is a member of another symbol; and so on. If you do not provide this information, the symbol will not be documented correctly. Warning : By using the @name tag, you are telling JSDoc to ignore the surrounding code and treat your documentation comment in isolation. In many cases, it is best to use the @alias tag instead, which changes a symbol's name in the documentation but preserves other information about the symbol.","title":"Overview"},{"location":"tags/name/#examples","text":"The following example shows how to use the @name tag to document a function that JSDoc would not normally recognize. {% example \"Using the @name tag\" %} /** * @name highlightSearchTerm * @function * @global * @param {string} term - The search term to highlight. */ eval(\"window.highlightSearchTerm = function(term) {};\") {% endexample %}","title":"Examples"},{"location":"tags/namespace/","text":"Syntax @namespace [[{<type>}] <SomeName>] Overview The @namespace tag indicates that an object creates a namespace for its members. You can also write a virtual JSDoc comment that defines a namespace used by your code. If a namespace is defined by a symbol other than an object literal, you can include a type expression along with the @namespace tag. If the @namespace tag includes a type, it must also include a name. You may need to document a namespace whose name includes unusual characters, such as \"#\" or \"!\". In these cases, when you document or link to the namespace, you must add quotation marks around the portion of the namespace that includes unusual characters. See the examples below for details. Examples {% example \"Using the @namespace tag with an object\" %} /** * My namespace. * @namespace */ var MyNamespace = { /** documented as MyNamespace.foo */ foo: function() {}, /** documented as MyNamespace.bar */ bar: 1 }; {% endexample %} {% example \"Using the @namespace tag for virtual comments\" %} /** * A namespace. * @namespace MyNamespace */ /** * A function in MyNamespace (MyNamespace.myFunction). * @function myFunction * @memberof MyNamespace */ {% endexample %} If a @namespace includes a symbol whose name has unusual characters, you must enclose the symbol's name in double quotes. If the symbol's name already contains one or more double quotes, escape the double quotes with a leading backslash (\\). {% example \"Using the @namespace tag with unusual member names\" %} /** @namespace window */ /** * Shorthand for the alert function. * Refer to it as {@link window.\"!\"} (note the double quotes). */ window[\"!\"] = function(msg) { alert(msg); }; {% endexample %}","title":"Namespace"},{"location":"tags/namespace/#syntax","text":"@namespace [[{<type>}] <SomeName>]","title":"Syntax"},{"location":"tags/namespace/#overview","text":"The @namespace tag indicates that an object creates a namespace for its members. You can also write a virtual JSDoc comment that defines a namespace used by your code. If a namespace is defined by a symbol other than an object literal, you can include a type expression along with the @namespace tag. If the @namespace tag includes a type, it must also include a name. You may need to document a namespace whose name includes unusual characters, such as \"#\" or \"!\". In these cases, when you document or link to the namespace, you must add quotation marks around the portion of the namespace that includes unusual characters. See the examples below for details.","title":"Overview"},{"location":"tags/namespace/#examples","text":"{% example \"Using the @namespace tag with an object\" %} /** * My namespace. * @namespace */ var MyNamespace = { /** documented as MyNamespace.foo */ foo: function() {}, /** documented as MyNamespace.bar */ bar: 1 }; {% endexample %} {% example \"Using the @namespace tag for virtual comments\" %} /** * A namespace. * @namespace MyNamespace */ /** * A function in MyNamespace (MyNamespace.myFunction). * @function myFunction * @memberof MyNamespace */ {% endexample %} If a @namespace includes a symbol whose name has unusual characters, you must enclose the symbol's name in double quotes. If the symbol's name already contains one or more double quotes, escape the double quotes with a leading backslash (\\). {% example \"Using the @namespace tag with unusual member names\" %} /** @namespace window */ /** * Shorthand for the alert function. * Refer to it as {@link window.\"!\"} (note the double quotes). */ window[\"!\"] = function(msg) { alert(msg); }; {% endexample %}","title":"Examples"},{"location":"tags/override/","text":"Overview The @override tag indicates that a symbol overrides a symbol with the same name in a parent class. This tag is provided for compatibility with Closure Compiler . By default, JSDoc automatically identifies symbols that override a parent. If your JSDoc comment includes the @inheritdoc tag , you do not need to include the @override tag. The presence of the @inheritdoc tag implies the presence of the @override tag. Example The following example shows how to indicate that a method overrides a method in its parent class: {% example \"Method that overrides a parent\" %} /** * @classdesc Abstract class representing a network connection. * @class */ function Connection() {} /** * Open the connection. */ Connection.prototype.open = function() { // ... }; /** * @classdesc Class representing a socket connection. * @class * @augments Connection */ function Socket() {} /** * Open the socket. * @override */ Socket.prototype.open = function() { // ... }; {% endexample %}","title":"Override"},{"location":"tags/override/#overview","text":"The @override tag indicates that a symbol overrides a symbol with the same name in a parent class. This tag is provided for compatibility with Closure Compiler . By default, JSDoc automatically identifies symbols that override a parent. If your JSDoc comment includes the @inheritdoc tag , you do not need to include the @override tag. The presence of the @inheritdoc tag implies the presence of the @override tag.","title":"Overview"},{"location":"tags/override/#example","text":"The following example shows how to indicate that a method overrides a method in its parent class: {% example \"Method that overrides a parent\" %} /** * @classdesc Abstract class representing a network connection. * @class */ function Connection() {} /** * Open the connection. */ Connection.prototype.open = function() { // ... }; /** * @classdesc Class representing a socket connection. * @class * @augments Connection */ function Socket() {} /** * Open the socket. * @override */ Socket.prototype.open = function() { // ... }; {% endexample %}","title":"Example"},{"location":"tags/package/","text":"Syntax With the JSDoc tag dictionary (enabled by default): @package With the Closure Compiler tag dictionary: @package [{typeExpression}] Overview The @package tag marks a symbol as package-private. Typically, this tag indicates that a symbol is available only to code in the same directory as the source file for this symbol. This tag is available in JSDoc 3.5.0 and later. By default, symbols marked with the @package tag will appear in your documentation. In JSDoc 3.3.0 and later, you can use the -a/--access command-line option to change this behavior. The @package tag is equivalent to @access package . Examples In the following example, the instance member Thingy#_bar appears in the generated documentation, but with an annotation indicating that it is package-private: {% example \"Using the @package tag\" %} /** @constructor */ function Thingy() { /** @package */ this._bar = 1; } {% endexample %}","title":"Package"},{"location":"tags/package/#syntax","text":"With the JSDoc tag dictionary (enabled by default): @package With the Closure Compiler tag dictionary: @package [{typeExpression}]","title":"Syntax"},{"location":"tags/package/#overview","text":"The @package tag marks a symbol as package-private. Typically, this tag indicates that a symbol is available only to code in the same directory as the source file for this symbol. This tag is available in JSDoc 3.5.0 and later. By default, symbols marked with the @package tag will appear in your documentation. In JSDoc 3.3.0 and later, you can use the -a/--access command-line option to change this behavior. The @package tag is equivalent to @access package .","title":"Overview"},{"location":"tags/package/#examples","text":"In the following example, the instance member Thingy#_bar appears in the generated documentation, but with an annotation indicating that it is package-private: {% example \"Using the @package tag\" %} /** @constructor */ function Thingy() { /** @package */ this._bar = 1; } {% endexample %}","title":"Examples"},{"location":"tags/param/","text":"Overview The @param tag provides the name, type, and description of a function parameter. The @param tag requires you to specify the name of the parameter you are documenting. You can also include the parameter's type, enclosed in curly brackets, and a description of the parameter. The parameter type can be a built-in JavaScript type, such as string or Object , or a JSDoc namepath to another symbol in your code. If you have written documentation for the symbol at that namepath, JSDoc will automatically link to the documentation for that symbol. You can also use a type expression to indicate, for example, that a parameter is not nullable or can accept any type; see the @type tag documentation for details. If you provide a description, you can make the JSDoc comment more readable by inserting a hyphen before the description. Be sure to include a space before and after the hyphen. Examples Names, types, and descriptions The following examples show how to include names, types, and descriptions in a @param tag. {% example \"Name only\" %} /** * @param somebody */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} {% example \"Name and type\" %} /** * @param {string} somebody */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} {% example \"Name, type, and description\" %} /** * @param {string} somebody Somebody's name. */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} You can add a hyphen before the description to make it more readable. Be sure to include a space before and after the hyphen. {% example \"Name, type, and description, with a hyphen before the description\" %} /** * @param {string} somebody - Somebody's name. */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} Parameters with properties If a parameter is expected to have a specific property, you can document that property by providing an additional @param tag. For example, if an employee parameter is expected to have name and department properties, you can document it as follows: {% example \"Documenting a parameter's properties\" %} /** * Assign the project to an employee. * @param {Object} employee - The employee who is responsible for the project. * @param {string} employee.name - The name of the employee. * @param {string} employee.department - The employee's department. */ Project.prototype.assign = function(employee) { // ... }; {% endexample %} If a parameter is destructured without an explicit name, you can give the object an appropriate one and document its properties. {% example \"Documenting a destructuring parameter\" %} /** * Assign the project to an employee. * @param {Object} employee - The employee who is responsible for the project. * @param {string} employee.name - The name of the employee. * @param {string} employee.department - The employee's department. */ Project.prototype.assign = function({ name, department }) { // ... }; {% endexample %} You can also combine this syntax with JSDoc's syntax for array parameters. For example, if multiple employees can be assigned to a project: {% example \"Documenting properties of values in an array\" %} /** * Assign the project to a list of employees. * @param {Object[]} employees - The employees who are responsible for the project. * @param {string} employees[].name - The name of an employee. * @param {string} employees[].department - The employee's department. */ Project.prototype.assign = function(employees) { // ... }; {% endexample %} Optional parameters and default values The following examples show how to indicate that a parameter is optional and has a default value. {% example \"An optional parameter (using JSDoc syntax)\" %} /** * @param {string} [somebody] - Somebody's name. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } alert('Hello ' + somebody); } {% endexample %} {% example \"An optional parameter (using Google Closure Compiler syntax)\" %} /** * @param {string=} somebody - Somebody's name. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } alert('Hello ' + somebody); } {% endexample %} {% example \"An optional parameter and default value\" %} /** * @param {string} [somebody=John Doe] - Somebody's name. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } alert('Hello ' + somebody); } {% endexample %} Multiple types and repeatable parameters The following examples show how to use type expressions to indicate that a parameter can accept multiple types (or any type), and that a parameter can be provided more than once. See the @type tag documentation for details about the type expressions that JSDoc supports. {% example \"Allows one type OR another type (type union)\" %} /** * @param {(string|string[])} [somebody=John Doe] - Somebody's name, or an array of names. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } else if (Array.isArray(somebody)) { somebody = somebody.join(', '); } alert('Hello ' + somebody); } {% endexample %} {% example \"Allows any type\" %} /** * @param {*} somebody - Whatever you want. */ function sayHello(somebody) { console.log('Hello ' + JSON.stringify(somebody)); } {% endexample %} {% example \"Allows a parameter to be repeated\" %} /** * Returns the sum of all numbers passed to the function. * @param {...number} num - A positive or negative number. */ function sum(num) { var i = 0, n = arguments.length, t = 0; for (; i &lt; n; i++) { t += arguments[i]; } return t; } {% endexample %} Callback functions If a parameter accepts a callback function, you can use the @callback tag to define a callback type, then include the callback type in the @param tag. {% example \"Parameters that accept a callback\" %} /** * This callback type is called `requestCallback` and is displayed as a global symbol. * * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage */ /** * Does something asynchronously and executes the callback on completion. * @param {requestCallback} cb - The callback that handles the response. */ function doSomethingAsynchronously(cb) { // code }; {% endexample %}","title":"Param"},{"location":"tags/param/#overview","text":"The @param tag provides the name, type, and description of a function parameter. The @param tag requires you to specify the name of the parameter you are documenting. You can also include the parameter's type, enclosed in curly brackets, and a description of the parameter. The parameter type can be a built-in JavaScript type, such as string or Object , or a JSDoc namepath to another symbol in your code. If you have written documentation for the symbol at that namepath, JSDoc will automatically link to the documentation for that symbol. You can also use a type expression to indicate, for example, that a parameter is not nullable or can accept any type; see the @type tag documentation for details. If you provide a description, you can make the JSDoc comment more readable by inserting a hyphen before the description. Be sure to include a space before and after the hyphen.","title":"Overview"},{"location":"tags/param/#examples","text":"","title":"Examples"},{"location":"tags/param/#names-types-and-descriptions","text":"The following examples show how to include names, types, and descriptions in a @param tag. {% example \"Name only\" %} /** * @param somebody */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} {% example \"Name and type\" %} /** * @param {string} somebody */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} {% example \"Name, type, and description\" %} /** * @param {string} somebody Somebody's name. */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %} You can add a hyphen before the description to make it more readable. Be sure to include a space before and after the hyphen. {% example \"Name, type, and description, with a hyphen before the description\" %} /** * @param {string} somebody - Somebody's name. */ function sayHello(somebody) { alert('Hello ' + somebody); } {% endexample %}","title":"Names, types, and descriptions"},{"location":"tags/param/#parameters-with-properties","text":"If a parameter is expected to have a specific property, you can document that property by providing an additional @param tag. For example, if an employee parameter is expected to have name and department properties, you can document it as follows: {% example \"Documenting a parameter's properties\" %} /** * Assign the project to an employee. * @param {Object} employee - The employee who is responsible for the project. * @param {string} employee.name - The name of the employee. * @param {string} employee.department - The employee's department. */ Project.prototype.assign = function(employee) { // ... }; {% endexample %} If a parameter is destructured without an explicit name, you can give the object an appropriate one and document its properties. {% example \"Documenting a destructuring parameter\" %} /** * Assign the project to an employee. * @param {Object} employee - The employee who is responsible for the project. * @param {string} employee.name - The name of the employee. * @param {string} employee.department - The employee's department. */ Project.prototype.assign = function({ name, department }) { // ... }; {% endexample %} You can also combine this syntax with JSDoc's syntax for array parameters. For example, if multiple employees can be assigned to a project: {% example \"Documenting properties of values in an array\" %} /** * Assign the project to a list of employees. * @param {Object[]} employees - The employees who are responsible for the project. * @param {string} employees[].name - The name of an employee. * @param {string} employees[].department - The employee's department. */ Project.prototype.assign = function(employees) { // ... }; {% endexample %}","title":"Parameters with properties"},{"location":"tags/param/#optional-parameters-and-default-values","text":"The following examples show how to indicate that a parameter is optional and has a default value. {% example \"An optional parameter (using JSDoc syntax)\" %} /** * @param {string} [somebody] - Somebody's name. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } alert('Hello ' + somebody); } {% endexample %} {% example \"An optional parameter (using Google Closure Compiler syntax)\" %} /** * @param {string=} somebody - Somebody's name. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } alert('Hello ' + somebody); } {% endexample %} {% example \"An optional parameter and default value\" %} /** * @param {string} [somebody=John Doe] - Somebody's name. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } alert('Hello ' + somebody); } {% endexample %}","title":"Optional parameters and default values"},{"location":"tags/param/#multiple-types-and-repeatable-parameters","text":"The following examples show how to use type expressions to indicate that a parameter can accept multiple types (or any type), and that a parameter can be provided more than once. See the @type tag documentation for details about the type expressions that JSDoc supports. {% example \"Allows one type OR another type (type union)\" %} /** * @param {(string|string[])} [somebody=John Doe] - Somebody's name, or an array of names. */ function sayHello(somebody) { if (!somebody) { somebody = 'John Doe'; } else if (Array.isArray(somebody)) { somebody = somebody.join(', '); } alert('Hello ' + somebody); } {% endexample %} {% example \"Allows any type\" %} /** * @param {*} somebody - Whatever you want. */ function sayHello(somebody) { console.log('Hello ' + JSON.stringify(somebody)); } {% endexample %} {% example \"Allows a parameter to be repeated\" %} /** * Returns the sum of all numbers passed to the function. * @param {...number} num - A positive or negative number. */ function sum(num) { var i = 0, n = arguments.length, t = 0; for (; i &lt; n; i++) { t += arguments[i]; } return t; } {% endexample %}","title":"Multiple types and repeatable parameters"},{"location":"tags/param/#callback-functions","text":"If a parameter accepts a callback function, you can use the @callback tag to define a callback type, then include the callback type in the @param tag. {% example \"Parameters that accept a callback\" %} /** * This callback type is called `requestCallback` and is displayed as a global symbol. * * @callback requestCallback * @param {number} responseCode * @param {string} responseMessage */ /** * Does something asynchronously and executes the callback on completion. * @param {requestCallback} cb - The callback that handles the response. */ function doSomethingAsynchronously(cb) { // code }; {% endexample %}","title":"Callback functions"},{"location":"tags/private/","text":"Syntax With the JSDoc tag dictionary (enabled by default): @private With the Closure Compiler tag dictionary: @private [{typeExpression}] Overview The @private tag marks a symbol as private, or not meant for general use. Private members are not shown in the generated output unless JSDoc is run with the -p/--private command-line option. In JSDoc 3.3.0 and later, you can also use the -a/--access command-line option to change this behavior. The @private tag is not inherited by child members. For example, if the @private tag is added to a namespace, members of the namespace can still appear in the generated output; because the namespace is private, the members' namepath will not include the namespace. The @private tag is equivalent to @access private . Examples In the following example, Documents and Documents.Newspaper appear in the generated documentation, but not Documents.Diary . {% example \"Using the @private tag\" %} /** @namespace */ var Documents = { /** * An ordinary newspaper. */ Newspaper: 1, /** * My diary. * @private */ Diary: 2 }; {% endexample %}","title":"Private"},{"location":"tags/private/#syntax","text":"With the JSDoc tag dictionary (enabled by default): @private With the Closure Compiler tag dictionary: @private [{typeExpression}]","title":"Syntax"},{"location":"tags/private/#overview","text":"The @private tag marks a symbol as private, or not meant for general use. Private members are not shown in the generated output unless JSDoc is run with the -p/--private command-line option. In JSDoc 3.3.0 and later, you can also use the -a/--access command-line option to change this behavior. The @private tag is not inherited by child members. For example, if the @private tag is added to a namespace, members of the namespace can still appear in the generated output; because the namespace is private, the members' namepath will not include the namespace. The @private tag is equivalent to @access private .","title":"Overview"},{"location":"tags/private/#examples","text":"In the following example, Documents and Documents.Newspaper appear in the generated documentation, but not Documents.Diary . {% example \"Using the @private tag\" %} /** @namespace */ var Documents = { /** * An ordinary newspaper. */ Newspaper: 1, /** * My diary. * @private */ Diary: 2 }; {% endexample %}","title":"Examples"},{"location":"tags/property/","text":"Overview The @property tag is a way to easily document a list of static properties of a class, namespace or other object. Normally JSDoc templates would create an entire new page to display information about each level of a nested namespace hierarchy. Sometimes what you really want is to just list all the properties, including nested properties, all together on the same page. Note that property tags must be used in doc comments for the thing that they are properties of, a namespace or a class for example. This tag is intended for simple collections of static properties, it does not allow you to provide @examples or similar complex information for each property, just the type, name and description. Examples In this example we have a namespace named \"config.\" We want all the information about the defaults property, including its nested values, to appear on the same page with the documentation for config. {% example \"A namespace with defaults and nested default properties\" %} /** * @namespace * @property {object} defaults - The default values for parties. * @property {number} defaults.players - The default number of players. * @property {string} defaults.level - The default level for the party. * @property {object} defaults.treasure - The default treasure. * @property {number} defaults.treasure.gold - How much gold the party starts with. */ var config = { defaults: { players: 1, level: 'beginner', treasure: { gold: 0 } } }; {% endexample %} The following example shows how to indicate that a property is optional. {% example \"A type definition with required and optional property\" %} /** * User type definition * @typedef {Object} User * @property {string} email * @property {string} [nickName] */ {% endexample %}","title":"Property"},{"location":"tags/property/#overview","text":"The @property tag is a way to easily document a list of static properties of a class, namespace or other object. Normally JSDoc templates would create an entire new page to display information about each level of a nested namespace hierarchy. Sometimes what you really want is to just list all the properties, including nested properties, all together on the same page. Note that property tags must be used in doc comments for the thing that they are properties of, a namespace or a class for example. This tag is intended for simple collections of static properties, it does not allow you to provide @examples or similar complex information for each property, just the type, name and description.","title":"Overview"},{"location":"tags/property/#examples","text":"In this example we have a namespace named \"config.\" We want all the information about the defaults property, including its nested values, to appear on the same page with the documentation for config. {% example \"A namespace with defaults and nested default properties\" %} /** * @namespace * @property {object} defaults - The default values for parties. * @property {number} defaults.players - The default number of players. * @property {string} defaults.level - The default level for the party. * @property {object} defaults.treasure - The default treasure. * @property {number} defaults.treasure.gold - How much gold the party starts with. */ var config = { defaults: { players: 1, level: 'beginner', treasure: { gold: 0 } } }; {% endexample %} The following example shows how to indicate that a property is optional. {% example \"A type definition with required and optional property\" %} /** * User type definition * @typedef {Object} User * @property {string} email * @property {string} [nickName] */ {% endexample %}","title":"Examples"},{"location":"tags/protected/","text":"Syntax With the JSDoc tag dictionary (enabled by default): @protected With the Closure Compiler tag dictionary: @protected [{typeExpression}] Overview The @protected tag marks a symbol as protected. Typically, this tag indicates that a symbol is only available, or should only be used, within the current module. By default, symbols marked with the @protected tag will appear in your documentation. In JSDoc 3.3.0 and later, you can use the -a/--access command-line option to change this behavior. The @protected tag is equivalent to @access protected . Examples In the following example, the instance member Thingy#_bar appears in the generated documentation, but with an annotation indicating that it is protected: {% example \"Using the @protected tag\" %} /** @constructor */ function Thingy() { /** @protected */ this._bar = 1; } {% endexample %}","title":"Protected"},{"location":"tags/protected/#syntax","text":"With the JSDoc tag dictionary (enabled by default): @protected With the Closure Compiler tag dictionary: @protected [{typeExpression}]","title":"Syntax"},{"location":"tags/protected/#overview","text":"The @protected tag marks a symbol as protected. Typically, this tag indicates that a symbol is only available, or should only be used, within the current module. By default, symbols marked with the @protected tag will appear in your documentation. In JSDoc 3.3.0 and later, you can use the -a/--access command-line option to change this behavior. The @protected tag is equivalent to @access protected .","title":"Overview"},{"location":"tags/protected/#examples","text":"In the following example, the instance member Thingy#_bar appears in the generated documentation, but with an annotation indicating that it is protected: {% example \"Using the @protected tag\" %} /** @constructor */ function Thingy() { /** @protected */ this._bar = 1; } {% endexample %}","title":"Examples"},{"location":"tags/public/","text":"Overview The @public tag indicates that a symbol should be documented as if it were public. By default, JSDoc treats all symbols as public, so using this tag does not normally affect the generated documentation. However, you may prefer to use the @public tag explicitly so it is clear to others that you intended to make the symbol public. In JSDoc 3, the @public tag does not affect a symbol's scope. Use the @instance , @static , and @global tags to change a symbol's scope. Examples {% example \"Using the @public tag\" %} /** * The Thingy class is available to all. * @public * @class */ function Thingy() { /** * The Thingy~foo member. Note that 'foo' is still an inner member * of 'Thingy', in spite of the @public tag. * @public */ var foo = 0; } {% endexample %}","title":"Public"},{"location":"tags/public/#overview","text":"The @public tag indicates that a symbol should be documented as if it were public. By default, JSDoc treats all symbols as public, so using this tag does not normally affect the generated documentation. However, you may prefer to use the @public tag explicitly so it is clear to others that you intended to make the symbol public. In JSDoc 3, the @public tag does not affect a symbol's scope. Use the @instance , @static , and @global tags to change a symbol's scope.","title":"Overview"},{"location":"tags/public/#examples","text":"{% example \"Using the @public tag\" %} /** * The Thingy class is available to all. * @public * @class */ function Thingy() { /** * The Thingy~foo member. Note that 'foo' is still an inner member * of 'Thingy', in spite of the @public tag. * @public */ var foo = 0; } {% endexample %}","title":"Examples"},{"location":"tags/readonly/","text":"Overview The @readonly tag indicates that a symbol is intended to be read-only. Note this is for the purpose of documentation only - JSDoc won't check whether you've actually treated the symbol as read-only in your code. Examples {% example \"Using the @readonly tag\" %} /** * A constant. * @readonly * @const {number} */ const FOO = 1; {% endexample %} {% example \"Using the @readonly tag with a getter\" %} /** * Options for ordering a delicious slice of pie. * @namespace */ var pieOptions = { /** * Plain. */ plain: 'pie', /** * A la mode. * @readonly */ get aLaMode() { return this.plain + ' with ice cream'; } }; {% endexample %}","title":"Readonly"},{"location":"tags/readonly/#overview","text":"The @readonly tag indicates that a symbol is intended to be read-only. Note this is for the purpose of documentation only - JSDoc won't check whether you've actually treated the symbol as read-only in your code.","title":"Overview"},{"location":"tags/readonly/#examples","text":"{% example \"Using the @readonly tag\" %} /** * A constant. * @readonly * @const {number} */ const FOO = 1; {% endexample %} {% example \"Using the @readonly tag with a getter\" %} /** * Options for ordering a delicious slice of pie. * @namespace */ var pieOptions = { /** * Plain. */ plain: 'pie', /** * A la mode. * @readonly */ get aLaMode() { return this.plain + ' with ice cream'; } }; {% endexample %}","title":"Examples"},{"location":"tags/requires/","text":"Syntax @requires <someModuleName> Overview The @requires tag allows you to document that a module is needed to use this code. A JSDoc comment can have multiple @require tags. The module name can be specified as \"moduleName\" or \"module:moduleName\"; both forms will be interpreted as modules. JSDoc does not attempt to process the module that is being included. If you want the module to be included in the documentation, you must include the module in the list of JavaScript files to process. Examples {% example \"Using the @requires tag\" %} /** * This class requires the modules {@link module:xyzcorp/helper} and * {@link module:xyzcorp/helper.ShinyWidget#polish}. * @class * @requires module:xyzcorp/helper * @requires xyzcorp/helper.ShinyWidget#polish */ function Widgetizer() {} {% endexample %}","title":"Requires"},{"location":"tags/requires/#syntax","text":"@requires <someModuleName>","title":"Syntax"},{"location":"tags/requires/#overview","text":"The @requires tag allows you to document that a module is needed to use this code. A JSDoc comment can have multiple @require tags. The module name can be specified as \"moduleName\" or \"module:moduleName\"; both forms will be interpreted as modules. JSDoc does not attempt to process the module that is being included. If you want the module to be included in the documentation, you must include the module in the list of JavaScript files to process.","title":"Overview"},{"location":"tags/requires/#examples","text":"{% example \"Using the @requires tag\" %} /** * This class requires the modules {@link module:xyzcorp/helper} and * {@link module:xyzcorp/helper.ShinyWidget#polish}. * @class * @requires module:xyzcorp/helper * @requires xyzcorp/helper.ShinyWidget#polish */ function Widgetizer() {} {% endexample %}","title":"Examples"},{"location":"tags/returns/","text":"Syntax @returns [{type}] [description] Overview The @returns tag documents the value that a function returns. If you are documenting a generator function, use the @yields tag instead of this tag. Examples {% example \"Return value with a type\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @returns {number} */ function sum(a, b) { return a + b; } {% endexample %} {% example \"Return value with a type and description\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @returns {number} Sum of a and b */ function sum(a, b) { return a + b; } {% endexample %} {% example \"Return value with multiple types\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @param {boolean} retArr If set to true, the function will return an array * @returns {(number|Array)} Sum of a and b or an array that contains a, b and the sum of a and b. */ function sum(a, b, retArr) { if (retArr) { return [a, b, a + b]; } return a + b; } {% endexample %} {% example \"Returns a promise\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @returns {Promise<number>} Promise object represents the sum of a and b */ function sumAsync(a, b) { return new Promise(function(resolve, reject) { resolve(a + b); }); } {% endexample %}","title":"Returns"},{"location":"tags/returns/#syntax","text":"@returns [{type}] [description]","title":"Syntax"},{"location":"tags/returns/#overview","text":"The @returns tag documents the value that a function returns. If you are documenting a generator function, use the @yields tag instead of this tag.","title":"Overview"},{"location":"tags/returns/#examples","text":"{% example \"Return value with a type\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @returns {number} */ function sum(a, b) { return a + b; } {% endexample %} {% example \"Return value with a type and description\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @returns {number} Sum of a and b */ function sum(a, b) { return a + b; } {% endexample %} {% example \"Return value with multiple types\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @param {boolean} retArr If set to true, the function will return an array * @returns {(number|Array)} Sum of a and b or an array that contains a, b and the sum of a and b. */ function sum(a, b, retArr) { if (retArr) { return [a, b, a + b]; } return a + b; } {% endexample %} {% example \"Returns a promise\" %} /** * Returns the sum of a and b * @param {number} a * @param {number} b * @returns {Promise<number>} Promise object represents the sum of a and b */ function sumAsync(a, b) { return new Promise(function(resolve, reject) { resolve(a + b); }); } {% endexample %}","title":"Examples"},{"location":"tags/see/","text":"Syntax @see <namepath> @see <text> Overview The @see tag allows you to refer to another symbol or resource that may be related to the one being documented. You can provide either a symbol's namepath or free-form text. If you provide a namepath, JSDoc's default template automatically converts the namepath to a link. Examples {% example \"Using the @see tag\" %} /** * Both of these will link to the bar function. * @see {@link bar} * @see bar */ function foo() {} // Use the inline {@link} tag to include a link within a free-form description. /** * @see {@link foo} for further information. * @see {@link http://github.com|GitHub} */ function bar() {} {% endexample %}","title":"See"},{"location":"tags/see/#syntax","text":"@see <namepath> @see <text>","title":"Syntax"},{"location":"tags/see/#overview","text":"The @see tag allows you to refer to another symbol or resource that may be related to the one being documented. You can provide either a symbol's namepath or free-form text. If you provide a namepath, JSDoc's default template automatically converts the namepath to a link.","title":"Overview"},{"location":"tags/see/#examples","text":"{% example \"Using the @see tag\" %} /** * Both of these will link to the bar function. * @see {@link bar} * @see bar */ function foo() {} // Use the inline {@link} tag to include a link within a free-form description. /** * @see {@link foo} for further information. * @see {@link http://github.com|GitHub} */ function bar() {} {% endexample %}","title":"Examples"},{"location":"tags/since/","text":"Syntax @since <versionDescription> Overview The @since tag indicates that a class, method, or other symbol was added in a specific version. Examples {% example \"Using the @since tag\" %} /** * Provides access to user information. * @since 1.0.1 */ function UserRecord() {} {% endexample %}","title":"Since"},{"location":"tags/since/#syntax","text":"@since <versionDescription>","title":"Syntax"},{"location":"tags/since/#overview","text":"The @since tag indicates that a class, method, or other symbol was added in a specific version.","title":"Overview"},{"location":"tags/since/#examples","text":"{% example \"Using the @since tag\" %} /** * Provides access to user information. * @since 1.0.1 */ function UserRecord() {} {% endexample %}","title":"Examples"},{"location":"tags/static/","text":"Overview The @static tag indicates that a symbol is contained within a parent and can be accessed without instantiating the parent. Using the @static tag will override a symbol's default scope, with one exception: Symbols in global scope will remain global. Examples The following example has the same effect as writing \"@function MyNamespace.myFunction\" and omitting the @memberof and @static tags: {% example \"Using @static in a virtual comment\" %} /** @namespace MyNamespace */ /** * @function myFunction * @memberof MyNamespace * @static */ {% endexample %} The following example forces a module's inner member to be documented as a static member: {% example \"Using @static to override the default scope\" %} /** @module Rollerskate */ /** * The 'wheel' variable is documented as Rollerskate.wheel * rather than Rollerskate~wheel. * @static */ var wheel = 1; {% endexample %}","title":"Static"},{"location":"tags/static/#overview","text":"The @static tag indicates that a symbol is contained within a parent and can be accessed without instantiating the parent. Using the @static tag will override a symbol's default scope, with one exception: Symbols in global scope will remain global.","title":"Overview"},{"location":"tags/static/#examples","text":"The following example has the same effect as writing \"@function MyNamespace.myFunction\" and omitting the @memberof and @static tags: {% example \"Using @static in a virtual comment\" %} /** @namespace MyNamespace */ /** * @function myFunction * @memberof MyNamespace * @static */ {% endexample %} The following example forces a module's inner member to be documented as a static member: {% example \"Using @static to override the default scope\" %} /** @module Rollerskate */ /** * The 'wheel' variable is documented as Rollerskate.wheel * rather than Rollerskate~wheel. * @static */ var wheel = 1; {% endexample %}","title":"Examples"},{"location":"tags/summary/","text":"Syntax @summary Summary goes here. Overview The @summary tag is a shorter version of the full description. It can be added to any doclet. Examples /** * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological, * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate, * loquacious, garrulous, chatty, extended, babbling description. * @summary A concise summary. */ function bloviate() {}","title":"Summary"},{"location":"tags/summary/#syntax","text":"@summary Summary goes here.","title":"Syntax"},{"location":"tags/summary/#overview","text":"The @summary tag is a shorter version of the full description. It can be added to any doclet.","title":"Overview"},{"location":"tags/summary/#examples","text":"/** * A very long, verbose, wordy, long-winded, tedious, verbacious, tautological, * profuse, expansive, enthusiastic, redundant, flowery, eloquent, articulate, * loquacious, garrulous, chatty, extended, babbling description. * @summary A concise summary. */ function bloviate() {}","title":"Examples"},{"location":"tags/this/","text":"Syntax @this <namePath> Overview The @this tag indicates what the this keyword refers to when used within another symbol. Examples In the following example, the @this tag causes \"this.name\" to be documented as \"Greeter#name\" rather than a global symbol called \"name\". /** @constructor */ function Greeter(name) { setName.apply(this, name); } /** @this Greeter */ function setName(name) { /** document me */ this.name = name; }","title":"This"},{"location":"tags/this/#syntax","text":"@this <namePath>","title":"Syntax"},{"location":"tags/this/#overview","text":"The @this tag indicates what the this keyword refers to when used within another symbol.","title":"Overview"},{"location":"tags/this/#examples","text":"In the following example, the @this tag causes \"this.name\" to be documented as \"Greeter#name\" rather than a global symbol called \"name\". /** @constructor */ function Greeter(name) { setName.apply(this, name); } /** @this Greeter */ function setName(name) { /** document me */ this.name = name; }","title":"Examples"},{"location":"tags/throws/","text":"Syntax @throws free-form description @throws {<type>} @throws {<type>} free-form description Overview The @throws tag allows you to document an error that a function might throw. You can include the @throws tag more than once in a single JSDoc comment. Examples {% example \"Using the @throws tag with a type\" %} /** * @throws {InvalidArgumentException} */ function foo(x) {} {% endexample %} {% example \"Using the @throws tag with a description\" %} /** * @throws Will throw an error if the argument is null. */ function bar(x) {} {% endexample %} {% example \"Using the @throws tag with a type and description\" %} /** * @throws {DivideByZero} Argument x must be non-zero. */ function baz(x) {} {% endexample %}","title":"Throws"},{"location":"tags/throws/#syntax","text":"@throws free-form description @throws {<type>} @throws {<type>} free-form description","title":"Syntax"},{"location":"tags/throws/#overview","text":"The @throws tag allows you to document an error that a function might throw. You can include the @throws tag more than once in a single JSDoc comment.","title":"Overview"},{"location":"tags/throws/#examples","text":"{% example \"Using the @throws tag with a type\" %} /** * @throws {InvalidArgumentException} */ function foo(x) {} {% endexample %} {% example \"Using the @throws tag with a description\" %} /** * @throws Will throw an error if the argument is null. */ function bar(x) {} {% endexample %} {% example \"Using the @throws tag with a type and description\" %} /** * @throws {DivideByZero} Argument x must be non-zero. */ function baz(x) {} {% endexample %}","title":"Examples"},{"location":"tags/todo/","text":"Syntax @todo text describing thing to do. Overview The @todo tag allows you to document tasks to be completed for some part of your code. You can use the @todo tag more than once in a single JSDoc comment. Examples {% example \"Using the @todo tag\" %} /** * @todo Write the documentation. * @todo Implement this function. */ function foo() { // write me } {% endexample %}","title":"Todo"},{"location":"tags/todo/#syntax","text":"@todo text describing thing to do.","title":"Syntax"},{"location":"tags/todo/#overview","text":"The @todo tag allows you to document tasks to be completed for some part of your code. You can use the @todo tag more than once in a single JSDoc comment.","title":"Overview"},{"location":"tags/todo/#examples","text":"{% example \"Using the @todo tag\" %} /** * @todo Write the documentation. * @todo Implement this function. */ function foo() { // write me } {% endexample %}","title":"Examples"},{"location":"tags/tutorial/","text":"Syntax @tutorial <tutorialID> Overview The @tutorial tag inserts a link to a tutorial file that is provided as part of the documentation. See the tutorials overview for instructions on creating tutorials. You can use the @tutorial tag more than once in a single JSDoc comment. Examples In the following example, the documentation for MyClass will link to the tutorials that have the identifiers tutorial-1 and tutorial-2 : {% example \"Using the @tutorial tag\" %} /** * Description * @class * @tutorial tutorial-1 * @tutorial tutorial-2 */ function MyClass() {} {% endexample %}","title":"Tutorial"},{"location":"tags/tutorial/#syntax","text":"@tutorial <tutorialID>","title":"Syntax"},{"location":"tags/tutorial/#overview","text":"The @tutorial tag inserts a link to a tutorial file that is provided as part of the documentation. See the tutorials overview for instructions on creating tutorials. You can use the @tutorial tag more than once in a single JSDoc comment.","title":"Overview"},{"location":"tags/tutorial/#examples","text":"In the following example, the documentation for MyClass will link to the tutorials that have the identifiers tutorial-1 and tutorial-2 : {% example \"Using the @tutorial tag\" %} /** * Description * @class * @tutorial tutorial-1 * @tutorial tutorial-2 */ function MyClass() {} {% endexample %}","title":"Examples"},{"location":"tags/type/","text":"Syntax @type {typeName} Overview The @type tag allows you to provide a type expression identifying the type of value that a symbol may contain, or the type of value returned by a function. You can also include type expressions with many other JSDoc tags, such as the @param tag . A type expression can include the JSDoc namepath to a symbol (for example, myNamespace.MyClass ); a built-in JavaScript type (for example, string ); or a combination of these. You can use any Google Closure Compiler type expression , as well as several other formats that are specific to JSDoc. If JSDoc determines that a type expression is invalid, it will display an error and stop running. You can turn this error into a warning by running JSDoc with the --lenient option. Note : Full support for Google Closure Compiler-style type expressions is available in JSDoc 3.2 and later. Earlier versions of JSDoc included partial support for Closure Compiler type expressions. Each type is specified by providing a type expression, using one of the formats described below. Where appropriate, JSDoc will automatically create links to the documentation for other symbols. For example, @type {MyClass} will link to the MyClass documentation if that symbol has been documented. Type name Syntax examples Description Symbol name (name expression) {% example %} {boolean} {myNamespace.MyClass} {% endexample %} Specifies the name of a symbol. If you have documented the symbol, JSDoc creates a link to the documentation for that symbol. Multiple types (type union) {% example \"This can be a number or a boolean.\" %} {(number|boolean)} {% endexample %} This means a value can have one of several types, with the entire list of types enclosed in parentheses and separated by | . Arrays and objects (type applications and record types) {% example \"An array of MyClass instances.\" %} {Array.<MyClass>} // or: {MyClass[]} {% endexample %} {% example \"An object with string keys and number values:\" %} {Object.<string, number>} {% endexample %} {% example \"An object called 'myObj' with properties 'a' (a number), 'b' (a string) and 'c' (any type).\" %} {{a: number, b: string, c}} myObj // or: {Object} myObj {number} myObj.a {string} myObj.b {*} myObj.c {% endexample %} JSDoc supports Closure Compiler's syntax for defining array and object types. You can also indicate an array by appending [] to the type that is contained in the array. For example, the expression string[] indicates an array of strings. For objects that have a known set of properties, you can use Closure Compiler's syntax for documenting record types. You can document each property individually, which enables you to provide more detailed information about each property. Nullable type {% example \"A number or null.\" %} {?number} {% endexample %} This indicates that the type is either the specified type, or null . Non-nullable type {% example \"A number, but never null.\" %} {!number} {% endexample %} Indicates that the value is of the specified type, but cannot be null . Variable number of that type {% example \"This function accepts a variable number of numeric parameters.\" %} @param {...number} num {% endexample %} Indicates that the function accepts a variable number of parameters, and specifies a type for the parameters. For example: {% example %} /** * Returns the sum of all numbers passed to the function. * @param {...number} num A positive or negative number */ function sum(num) { var i=0, n=arguments.length, t=0; for (; i<n; i++) { t += arguments[i]; } return t; } {% endexample %} Optional parameter {% example \"An optional parameter named foo.\" %} @param {number} [foo] // or: @param {number=} foo {% endexample %} {% example \"An optional parameter foo with default value 1.\" %} @param {number} [foo=1] {% endexample %} Indicates that the parameter is optional. When using JSDoc's syntax for optional parameters, you can also indicate the value that will be used if a parameter is omitted. Callbacks {% example %} /** * @callback myCallback * @param {number} x - ... */ /** @type {myCallback} */ var cb; {% endexample %} Document a callback using the @callback tag. The syntax is identical to the @typedef tag, except that a callback's type is always \"function.\" Type definitions {% example \"Documenting a type with properties 'id', 'name', 'age'.\" %} /** * @typedef PropertiesHash * @type {object} * @property {string} id - an ID. * @property {string} name - your name. * @property {number} age - your age. */ /** @type {PropertiesHash} */ var props; {% endexample %} You can document complex types using the @typedef tag, then refer to the type definition elsewhere in your documentation. Examples {% example \"Example\" %} /** @type {(string|Array.<string>)} */ var foo; /** @type {number} */ var bar = 1; {% endexample %} In many cases, you can include a type expression as part of another tag, rather than including a separate @type tag in your JSDoc comment. {% example \"Type expressions can accompany many tags.\" %} /** * @type {number} * @const */ var FOO = 1; // same as: /** @const {number} */ var FOO = 1; {% endexample %}","title":"Type"},{"location":"tags/type/#syntax","text":"@type {typeName}","title":"Syntax"},{"location":"tags/type/#overview","text":"The @type tag allows you to provide a type expression identifying the type of value that a symbol may contain, or the type of value returned by a function. You can also include type expressions with many other JSDoc tags, such as the @param tag . A type expression can include the JSDoc namepath to a symbol (for example, myNamespace.MyClass ); a built-in JavaScript type (for example, string ); or a combination of these. You can use any Google Closure Compiler type expression , as well as several other formats that are specific to JSDoc. If JSDoc determines that a type expression is invalid, it will display an error and stop running. You can turn this error into a warning by running JSDoc with the --lenient option. Note : Full support for Google Closure Compiler-style type expressions is available in JSDoc 3.2 and later. Earlier versions of JSDoc included partial support for Closure Compiler type expressions. Each type is specified by providing a type expression, using one of the formats described below. Where appropriate, JSDoc will automatically create links to the documentation for other symbols. For example, @type {MyClass} will link to the MyClass documentation if that symbol has been documented. Type name Syntax examples Description Symbol name (name expression) {% example %} {boolean} {myNamespace.MyClass} {% endexample %} Specifies the name of a symbol. If you have documented the symbol, JSDoc creates a link to the documentation for that symbol. Multiple types (type union) {% example \"This can be a number or a boolean.\" %} {(number|boolean)} {% endexample %} This means a value can have one of several types, with the entire list of types enclosed in parentheses and separated by | . Arrays and objects (type applications and record types) {% example \"An array of MyClass instances.\" %} {Array.<MyClass>} // or: {MyClass[]} {% endexample %} {% example \"An object with string keys and number values:\" %} {Object.<string, number>} {% endexample %} {% example \"An object called 'myObj' with properties 'a' (a number), 'b' (a string) and 'c' (any type).\" %} {{a: number, b: string, c}} myObj // or: {Object} myObj {number} myObj.a {string} myObj.b {*} myObj.c {% endexample %} JSDoc supports Closure Compiler's syntax for defining array and object types. You can also indicate an array by appending [] to the type that is contained in the array. For example, the expression string[] indicates an array of strings. For objects that have a known set of properties, you can use Closure Compiler's syntax for documenting record types. You can document each property individually, which enables you to provide more detailed information about each property. Nullable type {% example \"A number or null.\" %} {?number} {% endexample %} This indicates that the type is either the specified type, or null . Non-nullable type {% example \"A number, but never null.\" %} {!number} {% endexample %} Indicates that the value is of the specified type, but cannot be null . Variable number of that type {% example \"This function accepts a variable number of numeric parameters.\" %} @param {...number} num {% endexample %} Indicates that the function accepts a variable number of parameters, and specifies a type for the parameters. For example: {% example %} /** * Returns the sum of all numbers passed to the function. * @param {...number} num A positive or negative number */ function sum(num) { var i=0, n=arguments.length, t=0; for (; i<n; i++) { t += arguments[i]; } return t; } {% endexample %} Optional parameter {% example \"An optional parameter named foo.\" %} @param {number} [foo] // or: @param {number=} foo {% endexample %} {% example \"An optional parameter foo with default value 1.\" %} @param {number} [foo=1] {% endexample %} Indicates that the parameter is optional. When using JSDoc's syntax for optional parameters, you can also indicate the value that will be used if a parameter is omitted. Callbacks {% example %} /** * @callback myCallback * @param {number} x - ... */ /** @type {myCallback} */ var cb; {% endexample %} Document a callback using the @callback tag. The syntax is identical to the @typedef tag, except that a callback's type is always \"function.\" Type definitions {% example \"Documenting a type with properties 'id', 'name', 'age'.\" %} /** * @typedef PropertiesHash * @type {object} * @property {string} id - an ID. * @property {string} name - your name. * @property {number} age - your age. */ /** @type {PropertiesHash} */ var props; {% endexample %} You can document complex types using the @typedef tag, then refer to the type definition elsewhere in your documentation.","title":"Overview"},{"location":"tags/type/#examples","text":"{% example \"Example\" %} /** @type {(string|Array.<string>)} */ var foo; /** @type {number} */ var bar = 1; {% endexample %} In many cases, you can include a type expression as part of another tag, rather than including a separate @type tag in your JSDoc comment. {% example \"Type expressions can accompany many tags.\" %} /** * @type {number} * @const */ var FOO = 1; // same as: /** @const {number} */ var FOO = 1; {% endexample %}","title":"Examples"},{"location":"tags/typedef/","text":"Syntax @typedef [<type>] <namepath> Overview The @typedef tag is useful for documenting custom types, particularly if you wish to refer to them repeatedly. These types can then be used within other tags expecting a type, such as @type or @param . Use the @callback tag to document the type of callback functions. Examples This example defines a union type for parameters that can contain either numbers or strings that represent numbers. {% example \"Using the @typedef tag\" %} /** * A number, or a string containing a number. * @typedef {(number|string)} NumberLike */ /** * Set the magic number. * @param {NumberLike} x - The magic number. */ function setMagicNumber(x) { } {% endexample %} This example defines a more complex type, an object with several properties, and sets its namepath so it will be displayed along with the class that uses the type. Because the type definition is not actually exposed by the class, it is customary to document the type definition as an inner member. {% example \"Using @typedef to document a complex type for a class\" %} /** * The complete Triforce, or one or more components of the Triforce. * @typedef {Object} WishGranter~Triforce * @property {boolean} hasCourage - Indicates whether the Courage component is present. * @property {boolean} hasPower - Indicates whether the Power component is present. * @property {boolean} hasWisdom - Indicates whether the Wisdom component is present. */ /** * A class for granting wishes, powered by the Triforce. * @class * @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects * containing all three components of the Triforce. */ function WishGranter(triforce) {} {% endexample %}","title":"Typedef"},{"location":"tags/typedef/#syntax","text":"@typedef [<type>] <namepath>","title":"Syntax"},{"location":"tags/typedef/#overview","text":"The @typedef tag is useful for documenting custom types, particularly if you wish to refer to them repeatedly. These types can then be used within other tags expecting a type, such as @type or @param . Use the @callback tag to document the type of callback functions.","title":"Overview"},{"location":"tags/typedef/#examples","text":"This example defines a union type for parameters that can contain either numbers or strings that represent numbers. {% example \"Using the @typedef tag\" %} /** * A number, or a string containing a number. * @typedef {(number|string)} NumberLike */ /** * Set the magic number. * @param {NumberLike} x - The magic number. */ function setMagicNumber(x) { } {% endexample %} This example defines a more complex type, an object with several properties, and sets its namepath so it will be displayed along with the class that uses the type. Because the type definition is not actually exposed by the class, it is customary to document the type definition as an inner member. {% example \"Using @typedef to document a complex type for a class\" %} /** * The complete Triforce, or one or more components of the Triforce. * @typedef {Object} WishGranter~Triforce * @property {boolean} hasCourage - Indicates whether the Courage component is present. * @property {boolean} hasPower - Indicates whether the Power component is present. * @property {boolean} hasWisdom - Indicates whether the Wisdom component is present. */ /** * A class for granting wishes, powered by the Triforce. * @class * @param {...WishGranter~Triforce} triforce - One to three {@link WishGranter~Triforce} objects * containing all three components of the Triforce. */ function WishGranter(triforce) {} {% endexample %}","title":"Examples"},{"location":"tags/variation/","text":"Syntax @variation <variationNumber> Overview Sometimes your code may include multiple symbols with the same longname. For example, you might have both a global class and a top-level namespace called Widget . In cases such as these, what does \"{@link Widget}\" or \"@memberof Widget\" mean? The global namespace, or the global class? Variations help JSDoc distinguish between different symbols with the same longname. For example, if \"@variation 2\" is added to the JSDoc comment for the Widget class, \"{@link Widget(2)}\" will refer to the class, and \"{@link Widget}\" will refer to the namespace. Alternatively, you can include the variation when you specify the symbol's with tags such as @alias or @name (for example, \"@alias Widget(2)\"). You can provide any value with the @variation tag, as long as the combination of the value and the longname results in a globally unique version of the longname. As a best practice, use a predictable pattern for choosing the values, which will make it easier for you to document your code. Examples The following example uses the @variation tag to distinguish between the Widget class and the Widget namespace. {% example \"Using the @variation tag\" %} /** * The Widget namespace. * @namespace Widget */ // you can also use '@class Widget(2)' and omit the @variation tag /** * The Widget class. Defaults to the properties in {@link Widget.properties}. * @class * @variation 2 * @param {Object} props - Name-value pairs to add to the widget. */ function Widget(props) {} /** * Properties added by default to a new {@link Widget(2)} instance. */ Widget.properties = { /** * Indicates whether the widget is shiny. */ shiny: true, /** * Indicates whether the widget is metallic. */ metallic: true }; {% endexample %}","title":"Variation"},{"location":"tags/variation/#syntax","text":"@variation <variationNumber>","title":"Syntax"},{"location":"tags/variation/#overview","text":"Sometimes your code may include multiple symbols with the same longname. For example, you might have both a global class and a top-level namespace called Widget . In cases such as these, what does \"{@link Widget}\" or \"@memberof Widget\" mean? The global namespace, or the global class? Variations help JSDoc distinguish between different symbols with the same longname. For example, if \"@variation 2\" is added to the JSDoc comment for the Widget class, \"{@link Widget(2)}\" will refer to the class, and \"{@link Widget}\" will refer to the namespace. Alternatively, you can include the variation when you specify the symbol's with tags such as @alias or @name (for example, \"@alias Widget(2)\"). You can provide any value with the @variation tag, as long as the combination of the value and the longname results in a globally unique version of the longname. As a best practice, use a predictable pattern for choosing the values, which will make it easier for you to document your code.","title":"Overview"},{"location":"tags/variation/#examples","text":"The following example uses the @variation tag to distinguish between the Widget class and the Widget namespace. {% example \"Using the @variation tag\" %} /** * The Widget namespace. * @namespace Widget */ // you can also use '@class Widget(2)' and omit the @variation tag /** * The Widget class. Defaults to the properties in {@link Widget.properties}. * @class * @variation 2 * @param {Object} props - Name-value pairs to add to the widget. */ function Widget(props) {} /** * Properties added by default to a new {@link Widget(2)} instance. */ Widget.properties = { /** * Indicates whether the widget is shiny. */ shiny: true, /** * Indicates whether the widget is metallic. */ metallic: true }; {% endexample %}","title":"Examples"},{"location":"tags/version/","text":"Overview Documents the version of an item. The text following the @version tag will be used to denote the version of the item. Examples {% example \"Using the @version tag\" %} /** * Solves equations of the form a * x = b. Returns the value * of x. * @version 1.2.3 * @tutorial solver */ function solver(a, b) { return b / a; } {% endexample %}","title":"Version"},{"location":"tags/version/#overview","text":"Documents the version of an item. The text following the @version tag will be used to denote the version of the item.","title":"Overview"},{"location":"tags/version/#examples","text":"{% example \"Using the @version tag\" %} /** * Solves equations of the form a * x = b. Returns the value * of x. * @version 1.2.3 * @tutorial solver */ function solver(a, b) { return b / a; } {% endexample %}","title":"Examples"},{"location":"tags/yields/","text":"tag: yields description: Document the value yielded by a generator function. synonyms: - yield related: - tags-returns.html Syntax @yields [{type}] [description] Overview The @yields tag documents the value that is yielded by a generator function. This tag is available in JSDoc 3.5.0 and later. If you are documenting a regular function, use the @returns tag instead of this tag. Examples {% example \"@yields tag with a type\" %} /** * Generate the Fibonacci sequence of numbers. * * @yields {number} */ function* fibonacci() {} {% endexample %} {% example \"@yields tag with a type and description\" %} /** * Generate the Fibonacci sequence of numbers. * * @yields {number} The next number in the Fibonacci sequence. */ function* fibonacci() {} {% endexample %}","title":"Yields"},{"location":"tags/yields/#syntax","text":"@yields [{type}] [description]","title":"Syntax"},{"location":"tags/yields/#overview","text":"The @yields tag documents the value that is yielded by a generator function. This tag is available in JSDoc 3.5.0 and later. If you are documenting a regular function, use the @returns tag instead of this tag.","title":"Overview"},{"location":"tags/yields/#examples","text":"{% example \"@yields tag with a type\" %} /** * Generate the Fibonacci sequence of numbers. * * @yields {number} */ function* fibonacci() {} {% endexample %} {% example \"@yields tag with a type and description\" %} /** * Generate the Fibonacci sequence of numbers. * * @yields {number} The next number in the Fibonacci sequence. */ function* fibonacci() {} {% endexample %}","title":"Examples"}]}